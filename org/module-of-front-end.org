#+SETUPFILE: ../theme-rose.setup
#+DATE: <2020-01-19 Sun 19:49>
#+TITLE: Module Of Front End

** 序言

1995 年 5 月， Brendan Eich 只用了 10 天，就设计完成了 JavaScript 的第一版，so 对于 JavaScript 的规范化，不要要求太多，比如，它早期根本没有考虑模块化……

随着 web2.0 的发展， Ajax 技术得到广泛应用，各种前端库层出不穷， _前端代码日益膨胀_ ， JavaScript 极其简单的代码组织规范已经 hold 不住如此庞大规模的代码了。

下面一起来看一下， JavaScript 模块化规范的血泪历程！

** 模块化的基础[fn:3]

_1. 函数封装_

最开始的模块就是在一个文件里面编写几个相关的函数，如此用时加载函数所在文件，直接调用即可。

#+BEGIN_SRC js -n
  function fn1() {
      // ....
  }

  function fn2() {
      // ....
  }
#+END_SRC

_缺点_ ：污染了全局变量，容易引起命名冲突，而且模块成员之间没什么关系。

_2. 对象封装_

为了解决上述问题，可以把所有的模块成员封装在一个对象中。如下：

#+BEGIN_SRC js -n
  var moduleInObj = {
      var1: 'Tom',
      var2: 'Jerry',

      fn1: function() {
          // ....
      },
      fn2: function() {
          // ....
      }
  }
#+END_SRC

如此，在需要模块时，引用包含模块的文件，通过 =对象名.模块名= 调用即可。

_缺点_ ：外部可以随意修改内部成员，如 =moduleInObj.var2 = 'Bach'= 或 =moduleInObj.fn2 = function() { //....}= ，不安全啊。

_3. 立即执行函数封装_

为了隐藏细节，可以使用立即执行函数，如下：

#+BEGIN_SRC js -n
  var moduleInIIEF = (function() {
      var var1 = 'Tom';
      var var2 = 'Jerry';

      function fn1() {
          // ....
      }

      function fn2() {
          // ....
      }

      // 只暴露想要暴露的变量或函数
      return {
          var1: var1,
          fn2: fn2
      }
  })
#+END_SRC

如此，在模块外部无法修改没有暴露出来的变量、函数。

_总结_

上述做法就是模块化的基础了，现在，让我们来看一下当前通行的 JavaScript 模块规范。

** 服务器端模块化

*** CommonJS

CommonJS 是 NodeJS 在服务端的模块化规范：
- 一个单独的文件就是一个模块，每个模块都是一个独立的作用域；
- 模块只有一个出口 -- =module.exports= 对象，把模块需要暴露的内容放入该对象；
- 加载模块使用 =require= 方法，该方法读取一个文件并执行，返回文件内部的 =module.exports= 对象。

#+BEGIN_SRC js -n
  // moduleInCommonJS.js

  var var1 = 'Tom';
  var var2 = 'Jerry';

  function fn1() {
      // ....
  }

  function fn2() {
      // ....
  }

  // 通过 module.exports 对象暴露模块内容
  module.exports = {
      fn1: fn1,
      fn2: fn2
  }
#+END_SRC

如此，当需要使用模块功能时，如下操作：

#+BEGIN_SRC js -n
  // 使用 require 加载 moduleInCommonJS
  var moudleInCommonJS = require('./moduleInCommonJS.js');

  // 调用模块的函数
  moduleInCommonJS.fn1();
#+END_SRC

注意，不同的实现对 =require= 时的路径有不同要求，通常可以省略 =.js= 扩展名，可以使用相对路径，也可以使用绝对路径。对于系统内置模块，甚至可以不写路径，直接使用模块名。

CommonJS 中的 =require= 加载是 _同步的_ ，模块系统需要 _同步读取_ 模块文件的内容（服务端内的硬盘读写速度很快），并编译执行以得到模块接口。

然而，浏览器端就尴尬了 -_||

*** NodeJS 如何实现不同模块可以使用相同的变量名[fn:2]

JavaScript 语言本身并没有一种机制来保证不同的模块可以使用相同的变量名，那么 Node.js 是如何实现这一点的呢？

*！！！闭包！！！*

JavaScript 是一种函数式编程语言，它支持闭包 -- 把一段 JS 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。

如我们编写的 =hello.js= 代码如下：

#+BEGIN_SRC js -n
  var s = 'Hello'
  var name = 'world'

  console.log(s + ' ' + name + '!')
#+END_SRC

↓↓↓ Node.js 加载了 =hello.js= 后，会把代码包装一下再执行，如下：

#+BEGIN_SRC js -n
  (function () {
      // 读取的 hello.js 代码
      var s = 'Hello'
      var name = 'world'

      console.log(s + ' ' + name + '!')
      // hello.js 代码结束
  })()
#+END_SRC

如此以来，原来的全局变量 =s= 现在变成了匿名函数内部的局部变量。

*** 模块的输出 module.exports 如何实现

Node 利用 JavaScript 的函数式编程的特性，轻而易举实现了模块的隔离。但是，模块的输出 =module.exports= 怎么实现呢？

首先，Node 可以先准备一个对象 =module= ：

#+BEGIN_SRC js -n
  // 准备 module 对象
  var module = {
      id: 'hello',
      exports: {}
  }

  var load = function(module) {
      // 读取的 hello.js 代码
      function greet(name) {
          console.log('Hello, ' + name + '!')
      }

      module.exports = greet
      // hello.js 代码结束

      return module.exports
  }

  var exported = load(moudle)

  // 保存 module
  save(module, exported)
#+END_SRC

可见，变量 =module= 是 Node 在加载 js 文件之前准备的一个变量，并将其传入加载函数，我们可以直接使用变量 =module= 原因就在于它实际上是函数的一个参数。

#+BEGIN_EXAMPLE
exported →→ load(module) →→ module.exports
↓↓↓
save(module.exported) →→ save(module, module.exports)
#+END_EXAMPLE

Node 会把 =module= 变量保存到某个地方，i.e. Node 保存了所有导入的 =module= ，当我们用 =require()= 获取 module 时，Node 找到对应的 =module= ，并把这个 =module= 的 =exports= 变量返回，这样另一个模块就顺利拿到了模块的输出。

*** exports 和 module.exports 的异同

默认情况下，Node 准备的 =export= 变量和 =module.exports= 变量实际上是同一个变量，并且初始化为空对象 ={}= ，如此你就可以直接往里面加东西，如：

#+BEGIN_SRC js -n
  exports.foo = function() { return 'foo' }
  exports.bar = function() { return 'bar' }

  module.exports.foo = function() { return 'foo' }
  module.exports.bar = function() { return 'bar' }
#+END_SRC

但是，如果我们要输出的是一个函数或数组，那么，只能给 =module.exports= 赋值，如：

#+BEGIN_SRC js -n
  module.exports = function() { return 'foo' }; // ✔
  exports = function() { return 'foo};          // ✘
#+END_SRC

为什么呢？

其实，从 [[*%E6%A8%A1%E5%9D%97%E7%9A%84%E8%BE%93%E5%87%BA module.exports %E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0][模块的输出 module.exports 如何实现 ↑]] 章节的 =load= 加载函数中就可以知道，最终返回的只有 =module.exports= ！ =exports= 不过是指向 =module.exports= ，也就是说， =exports= 的内存地址中的值存储的是指向 =module.exports= 的指针， =module.exports= 中的值才是真正返回的对象。

#+BEGIN_EXAMPLE
  exports → module.exports → {}

  exports ✘ module.exports → otherObjectTwo
  ↓
  otherObjectOne

  // 加载函数返回的只是 module.exports
#+END_EXAMPLE

*！！！推荐始终使用 =module.exports= 这种相对安全的输出方式。*

** 浏览器端模块化

浏览器端，加载 JavaScript 文件的方式，是在文档头部插入 =<script>= 标签，但是脚本标签天生 _异步_ ，传统的 CommonJS 模块在浏览器环境中就变成了 _普通的 =.js= 文件_ -- 即没有避免全局变量污染，也没有解决依赖性。

那么，浏览器端的模块化，到底如何去规范呢？？

解决思路之一：开发一个服务器端组件，对模块代码作静态分析，将 _模块与它的依赖列表_ 一起返回给浏览器端。这需要服务器安装额外的组件，并因此要调整一系列底层架构。

解决思路之二：用一套标准模板来封装模块定义，但是如何定义，如何加载呢？

*** AMD·RequireJS

→ [[https://requirejs.org/][RequireJS]]

AMD（Asynchronous Module Definition）异步模块定义，是一个浏览器端模块化开发的规范，是 RequireJS 在推广过程中对模块定义的规范化产出。

#+BEGIN_QUOTE
注意， AMD 并不是 JavaScript 原生支持，使用 AMD 需要引入对应的库函数 -- RequireJS 。
#+END_QUOTE

RequireJS 主要解决两个问题：模块的 _异步加载_ 和 _依赖性_ 。

_1. 定义模块_

RequireJS 定义了一个全局函数 =define= ，用来定义模块，语法如下：

#+BEGIN_EXAMPLE
  define(id?, dependencies?, factory);
#+END_EXAMPLE

其中：
- =id= ，可选参数，用来定义模块的标识，缺省为脚本文件名；
- =dependencies= ，是一个当前模块依赖的模块名称数组；
- =factory= ，工厂方法，模块初始化要执行的 _函数或对象_ ，如果为函数，它应该只被执行一次；如果是对象，它应该为模块的输出值。

_2. 加载模块_

AMD 推崇 _依赖前置_ ，在定义模块的时候就要声明其依赖的模块。

在页面上使用 =require= 函数加载模块，语法如下：

#+BEGIN_EXAMPLE
  require(dependencies?, callback);
#+END_EXAMPLE

其中， =require()= 函数接受两个参数：
- =dependencies= ，表示所以来的模块数组；
- =callback= ，是一个回调函数，当依赖的模块都加载成功后，被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。

_3. 示例代码_

来看一个简单的 RequireJS 示例代码。

假设文件的目录架构，如下：

#+BEGIN_EXAMPLE
  Proj
  |
  |-- js
  |   |-- lib
  |       |-- jquery.js
  |       |-- require.js
  |
  |-- index.html
  |-- main.js
#+END_EXAMPLE

在 =index.html= 头部引入 =require.js= 文件，如下：

#+BEGIN_SRC html -n
  <scrpit data-main="./main" src="js/lib/require.js" defer async></scrpit>
#+END_SRC

其中，当 =require.js= 加载的时候会检查 =data-main= 属性，以获取 _入口脚本_ （这里是 =main.js= ）。

编写 =main.js= 即可，如下：

#+BEGIN_SRC js -n
  require.config({
      baseUrl: './js/',
      paths: {
          'jquery': 'lib/jquery'
      }
  });

  require(['jquery'], function($) {
      // jquery → $
      $(document).ready(() => {
          console.log('Hello World.');
      })
  })
#+END_SRC

*** CMD·SeaJS

→ [[https://seajs.github.io/seajs/docs/][SeaJS]]

CMD（Common Module Definition）通用模块定义，是国内发展出来的浏览器端模块化开发规范，相似， CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

_1. 定义模块_

SeaJS 也是为了解决模块的依赖性，语法如下：

#+BEGIN_EXAMPLE
define(id?, deps?, factory)
#+END_EXAMPLE

其中， =factory= 接受三个参数 -- =function(require, exports, module)= ，如下：
- 第一个参数 =require(id)= 是一个方法，接受模块标识作为唯一此参数，用来获取其他模块提供的接口；
- 第二个参数 =exports= 是一个对象，用来向外提供模块接口；
- 第三个参数 =module= 是一个对象，上面存储了与当前模块相关联的一些属性和方法。

_2. 加载模块_

CMD 推崇 _就近依赖_ ，只有在用到某个模块的时候再去 =require= 加载。

_3. 示例代码_

来看一个简单的 SeaJS 示例代码：

#+BEGIN_SRC js -n
  // → hello.js
  define(function(require, exports, module) {
      var $ = require('jquery');

      exports.sayHello = function() {
          $('#hello').toogle('slow');
      };
  });
#+END_SRC

通过 SeaJS 来加载使用上面的模块，如下：

#+BEGIN_SRC js -n
  seajs.config({
      alias: {
          'jquery': 'http:/modules.seajs.org/jquery/1.7.2/jquery.js'
      }
  });

  seajs.use(['./hello', 'jquery'], function(hello, $) {
      $('#beautiful-sea').click(hello.sayHello);
  });
#+END_SRC

_4. AMD vs CMD_

AMD 和 CMD 的模块加载都是异步的，最大的区别是对 _依赖模块的执行时机_ 处理不同。

AMD 在加载模块完成后就会执行该模块，所有模块都加载执行完成后，进入 require 的回调函数执行主逻辑。如此，依赖模块的执行顺序和书写顺序便无法保证一致 -- _谁下载快谁先执行_ ，但是主逻辑一定在所有依赖加载完成后才执行。

CMD 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。

一般来说， AMD 用户体验好，因为没延迟，依赖模块提前执行了； CMD 性能号，因为只有用户需要的时候才执行。

** ES6 模块化[fn:1]

ES6 模块的设计思想是尽量的 _静态化_ ，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 CommondJS 和 AMD 模块，都只能在运行时确定这些东西。比如， CommonJS 模块就是对象，输入时必须查找对象属性。

_1. ES6 模块的定义和加载_

ES6 的模块化语法： =export= 命令用于规定模块的对外接口， =import= 命令用于输入其他模块提供的功能。如下：

#+BEGIN_SRC js -n
  // 定义模块 math.js
  var basicNum = 0;
  var add = function(a, b) {
      return a + b;
  };

  export {basicNum, add};
#+END_SRC

如需用到该模块，使用 =import= 引用即可，如下：

#+BEGIN_SRC js -n
  // 引用模块
  import { basicNum, add } from './math';

  function test(ele) {
      ele.textContent = add(99 + basicNum);
  }
#+END_SRC

注意，使用 =import= 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 =export default= 命令，为模块指定默认输出。

#+BEGIN_SRC js -n
  // export-default.js
  export default function() {
      console.log('Hello World');
  }
#+END_SRC

如此，其他模块加载该模块的时候， =import= 命令可以为该匿名函数指定任意名字，如：

#+BEGIN_SRC js -n
  // import-default.js
  import customName from './export-default';

  customName();                   // → 'Hello World'
#+END_SRC

_2. ES6 模块和 CommonJS 模块的差异_

它们有两个重大差异：
- CommonJS 模块输出的是一个 _值的拷贝_ ，ES6 模块输出的是 _值的引用_ ；
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

来看一个代码示例：

#+BEGIN_SRC js -n
  // lib.js
  export let conuter = 3;
  export function incCounter() {
      counter++;
  }

  // 在 main.js 中加载 lib.js
  import { counter, incCounter } from './lib';

  console.log(counter);           // → 3

  incCounter();
  console.log(counter);           // → 4
#+END_SRC

可见，ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是 _动态引用_ ，并不会缓存值，模块里面的变量绑定其所在的模块。

第二个差异是因为 CommonJS 加载的是一个对象（即 =module.exports= 属性），该对象只有在脚本运行完才会生成；而 ES6 模块不是对象，它的对外接口只是已经静态定义，在代码静态解析阶段就会生成。

** 总结

小结一下：
- CommonJS 规范主要用于服务端编程，加载模块是同步的，并不适合浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD 、CMD 解决方案；
- AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；
- CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。但是依赖 SPM 打包，模块的加载逻辑偏重；
- ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

* Footnotes

[fn:3] https://www.cnblogs.com/dolphinX/p/4381855.html

[fn:2] https://www.liaoxuefeng.com/wiki/1022910821149312/1023027697415616

[fn:1] https://github.com/ljianshu/Blog/issues/48

