#+SETUPFILE: ../theme-rose.setup
#+DATE: <2020-05-15 Fri 22:46>
#+TITLE: Simple Shell

** 第一个 shell 脚本

#+BEGIN_SRC sh -n
  #!/bin/sh
  echo "Hello World!"
#+END_SRC

** 变量

#+BEGIN_SRC sh -n
  # 定义变量
  dec_var="declare variable"

  # 使用变量
  echo $dec_var                   # → declare variable
  echo ${dec_var}                 # → declare variable

  # 只读变量
  ro_var="readonly variable"
  readonly ro_var
  ro_var="re declare variable"    # → /bin/sh: Name: This variable is read only.

  # 删除变量
  del_var="delete variable"
  unset del_var
  echo $del_var                   # 没有任何输出
#+END_SRC

** 字符串

#+BEGIN_SRC sh -n
  u_name="Jack"
  echo "hello, ${u_name}!"        # → hello, Jack!

  # 单引号里的任何字符都会原样输出
  echo 'hello, ${u_name}!'        # → hello, ${u_name}!

  # 拼接字符串
  echo "hello, "$u_name"!"        # → hello, Jack!
  echo "hello, ${u_name}!"        # → hello, Jack!

  echo 'hello, '$u_name'!'        # → hello, Jack!
  echo 'hello, ${u_name}!'        # → hello, ${u_name}!

  # 获取字符串长度
  echo ${#u_name}                 # → 4

  # 提取子字符串
  echo ${u_name:1:3}              # → ack - 从 3 开始截取 3 个字符

  # 查找子字符串
  echo `expr index "$u_name" ck`  # → 2 - 字符 c 或 k 先出现的位置
#+END_SRC

** 数组

#+BEGIN_SRC sh -n
  # 定义数组
  # arr_name=(val1 val2 ... valN)
  arr_one_name=(0 1 2 3 4 5)

  arr_two_name[0]="val0"
  arr_two_name[1]="val1"
  arr_two_name[n]="valN"

  # 读取数组
  echo ${arr_two_name[n]}         # → valN
  # 使用 @ 或 * 符号获取数组中的所有元素
  echo ${arr_two_name[@]}         # → val0 val1 valN

  # 获取数组长度
  echo ${#arr_one_name[@]}        # → 6
  echo ${#arr_one_name[*]}        # → 6
#+END_SRC

** 注释

#+BEGIN_SRC sh -n
  # 这是一个单行注释
  # ---------------------------------
  # 多行注释

  :<<EOF
  注释内容...
  注释内容...
  注释内容...
  EOF

  # OR 其他符号

  :<<!
  注释内容...
  注释内容...
  注释内容...
  !
#+END_SRC

** 脚本传参

#+BEGIN_SRC sh -n
  # !/bin/sh
  # test.sh
  echo "执行的文件名： $0";
  echo "第一个参数为： $1";
  echo "第一个参数为： $2";
  echo "第一个参数为： $3";

  # 执行
  # chomod +x test.sh
  # ./test.sh 1 2 3
  # 结果如下 ↓↓↓
  # ---------------------------------
  # 执行的文件名： ./test.sh
  # 第一个参数为： 1
  # 第一个参数为： 2
  # 第一个参数为： 3
  # ---------------------------------
#+END_SRC

** 基本运算

#+BEGIN_SRC sh -n
  # 1. 算术运算符 + - * / % = == !=
  # 原生 bash 不支持简单的数字运算，需要通过其他命令来实现，如 awk 或 expr
  # 表达式要被 `` 包含
  # 表达式和运算符之间必须有空格，否则报错（Hmm...）
  echo `expr 1 + 1`               # → 2
  echo `expr 2 * 3`               # → 6

  # 2. 关系运算符 -eq -ne -gt -lt -ge -le
  # 注意关系运算符只支持数字，不支持字符串
  a=10
  b=20
  if [ $a -eq $b ]
  then
      echo "a 等于 b"
  else
      echo "a 不等于 b"
  fi

  # 3. 布尔运算符 ! -o -a
  # 4. 逻辑运算符 && ||
  # 5. 字符串运算符
  # ---------------------------------
  # = !=
  # -z 检测字符串是否为 0 ，为 0 返回 true
  # -n 检测字符串是否不为 0 ，不为 0 返回 true
  # $  检测字符串是否为空，不为空返回 true
  # ---------------------------------

  # 6. 文件测试运算符
  # 文件测试运算符用于检测 Unix 文件的各种属性，部分如下：
  # -d file 检测是否是目录，是，返回 true
  # -f file 检测文件是否为普通文件，是，返回 true
  # -r file 检测文件是否为可读，是，返回 true
  # -w file 检测文件是否为可写，是，返回 true
  # -x file 检测文件是否为可执行，是，返回 true
  # -s file 检测文件是否为空，不为空返回 true
  # -e file 检测文件（包括目录）是否存在，是，返回 true
#+END_SRC

** 流程控制

*** 条件

#+BEGIN_SRC sh -n
  # sh 的流程控制不可为空
  # 如果 else 分支没有语句执行，就不要写这个 else
  # 1. if
  if condition1
  then
      command1
  fi
  # or 写成一行
  if condition1; then command1; fi

  # 2. if else
  if condition1
  then
      command1
  else
      command2
  fi

  # 3. if elif else
  if condition1
  then
      command1
  elif condition2
  then
      command2
  else
      commandN
  fi
#+END_SRC

*** 循环

_1. for 循环_

#+BEGIN_SRC sh -n
  for var in item1 item2 ... itemN
  do
      command1
      command2
      ...
      commandN
  done
  # 或
  for var in item1 item2 ... itemN; do command1; command2… done;
#+END_SRC

_2. while 语句_

#+BEGIN_SRC sh -n
  while condition
  do
      command
  done
#+END_SRC

_3. until 语句_

#+BEGIN_SRC sh -n
  # 当 condition 为 false 时才执行
  until condition
  do
      command
  done
#+END_SRC

_4. case 语句_

#+BEGIN_SRC sh -n
  case 值 in
  模式1)
      command1
      command2
      command3
      ;;
  模式2）
      command1
      command2
      command3
      ;;
  *)
      command1
      command2
      command3
      ;;
  esac
#+END_SRC

来看个例子：

#+BEGIN_SRC sh -n
  #!/bin/sh

  site="runoob"

  case "$site" in
     "runoob") echo "菜鸟教程"
     ;;
     "google") echo "Google 搜索"
     ;;
     "taobao") echo "淘宝网"
     ;;
  esac

  # → "菜鸟教程"
#+END_SRC

** 函数

函数定义格式：

#+BEGIN_EXAMPLE
  [ function ] funname [()]{
      action;
      [return int;]
  }
#+END_EXAMPLE

#+BEGIN_SRC sh -n
  demoFun(){
      echo "This is a function."
  }

  demoFun                         # → This is a function.
#+END_SRC

函数传参：

#+BEGIN_SRC sh -n
  funWithParam(){
      echo "第一个参数为 $1 !"
      echo "第二个参数为 $2 !"
      echo "第十个参数为 $10 !"
      echo "第十个参数为 ${10} !"
      echo "第十一个参数为 ${11} !"
      echo "参数总数为 $#  个!"
      echo "作为一个字符串输出所有参数 $* !"
  }

  funWithParam 1 2 3 4 5 6 7 8 9 34 73

  # 输出结果 ↓↓↓
  # ---------------------------------
  # 第一个参数为 1 !
  # 第二个参数为 2 !
  # 第十个参数为 10 ! --> 当n>=10时，需要使用${n}来获取参数
  # 第十个参数为 34 !
  # 第十一个参数为 73 !
  # 参数总数有 11 个!
  # 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
  # ---------------------------------
#+END_SRC

** 输入/输出重定向

#+BEGIN_EXAMPLE
  command > file                  # 输出重定向
  command >> file                 # 输出追加重定向

  command < file                  # 输入重定向

  n > file                        # 将文件描述符为 n 的文件重定向到 file
  n >> file                       # 追加

  n >& m                          # 将输出文件 m 和 n 合并
  n <& m                          # 将输入文件 m 和 n 合并
#+END_EXAMPLE

** 文件包含

语法格式如下：

#+BEGIN_EXAMPLE
  . filename                      # 注意点号（.） 和文件名中间有一空格
  # 或
  source filename
#+END_EXAMPLE

注：被包含的文件 =test1.sh= 不需要可执行权限。
