#+SETUPFILE: ../theme-rose.setup
#+DATE: <2020-01-20 Mon 19:31>
#+TITLE: Async And Sync

** 单线程的 JavaScript [fn:1]

JavaScript 语言的核心特征之一就是 _单线程_ ，即同一时间只能做一件事。作为浏览器脚本语言， JavaScript 的主要用途是与用户互动，以及操作 DOM ，这 _决定_ 了它只能是单线程，否则会带来很复杂的同步问题。

为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。

** JS 的运行机制[fn:2]

#+BEGIN_EXPORT html
<img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" width="50%" />
#+END_EXPORT

如图所示， _主线程_ 运行的时候，产生堆（heap）和 _栈（stack）_ ，栈中的代码调用各种 WebAPI ，它们在 _“任务队列”_ 中加入各种事件，只要栈中的代码执行完毕，主线程就会去读取“任务队列”，一次执行那些事件所对应的 _回调函数_ 。

其中：
- _回调函数_ ，就是那些会被主线程挂起来的代码，异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的对调函数。
- _任务队列_ ，是一个 _先进先出_ 的数据结构，排在前面的事件，优先被主线程读取。除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等）及 _定时事件_ 。

** 同步和异步[fn:3]

#+BEGIN_EXPORT html
<img src="/images/web/async-and-sync.jpg" width="70%" />
#+END_EXPORT

JavaScript 是单线程的，同一时间只能做一件事，为了避免某些任务耗时过久造成页面响应迟钝，需要将此类任务异步执行。

其实，除了广义的同步任务和异步任务，我们对任务有更精细的定义，如下：
- _宏任务（Macro Task）_ ，包括整体代码 script ，setTimeout ，setInterval ；
- _微任务（Micro Task）_ ，包括 Promise ， process.nextTick 。

我们来看一段示例代码，如下：

#+BEGIN_SRC js -n
  setTimeout(() => {
      console.log('setTimeout....')
  }, 300)

  new Promise((resolve) => {
      console.log('promise....');
  }).then(() => {
      console.log('then....');
  })

  console.log('console....');

  // → promise....
  // → console....
  // → then....
  // → setTimeout....
#+END_SRC

不同类型的任务会进入对应的任务队列，上述代码执行过程如下：
1) 读取该段代码作为宏任务，进入主线程；
2) 遇到 =setTimeout= ，调用定时器 API ，将其回调函数注册后分发到 _宏任务队列_ ；
3) 接下来遇到了 =Promise= ， =new Promise= 立即执行， =then= 函数分发到 _微任务队列_ ；
4) 遇到 =console.log()= ，立即执行；
5) 整体代码 script 作为第一个宏任务执行结束，看看有哪些微任务，发现了 =then= 在微任务里面，执行；
6) 第一轮事件循环结束了，开始第二轮循环，从宏任务队列开始....
7) 直到所有任务队列为空，结束。

事件循环，宏任务，微任务的关系如图所示：

#+BEGIN_EXPORT html
<img src="/images/web/macro-and-micro.jpg" width="70%" />
#+END_EXPORT

_总结_

本质上，JavaScript 是单线程的，不管是新框架、新语法糖实现的所谓异步，其实都用同步的方法去模拟的。事件循环，是 JavaScript 实现异步的一种方法，也是 JavaScript 的执行机制。

** DONE 关于定时器

   - State "DONE"       from "TODO"       [2020-01-23 Thu 09:31]
除了放置异步任务的事件，“任务队列”还可以放置定时器事件，以指定某些代码在多少事件之后执行。

定时器功能主要由 =setTimeout()= 和 =setInterval()= 这两个函数来完成，它们的内部运行机制完全一样，却别在于前者指定的代码是一次性执行，后者则为循环执行。

#+BEGIN_SRC js -n
  setTimeout(function() {
      console.log('setTimeout....');
  }, 300)
#+END_SRC
其中， =setTimeout(fn, ms)= 接收两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。

当第二个参数 =ms= 为 =0= 时，表示指定某个任务在主线程最早可得的空闲时间执行，即尽可能早的执行。它在“任务队列”的尾部添加一个事件，因此要等到同步任务和“任务队列”中显示的事件都处理完，才会得到执行。

需要注意的是， =setTimeout()= 只是将事件插入了“任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以 _并没有办法保证_ 回调函数一定会在 =setTimeout()= 指定的时间执行。

** Node 中的事件循环

#+BEGIN_QUOTE
该章节摘录自 → [[http://www.ruanyifeng.com/blog/2014/10/event-loop.html][Mr.Ruan's Blog]] ，仅供学习参考。
#+END_QUOTE

NodeJS 也是单线程的 Event Loop ，但是它的运行机制不同于浏览器环境。如下图：

#+BEGIN_EXPORT html
<img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100803.png" width="80%" />
#+END_EXPORT

其中，NodeJS 的运行机制如下：
1) V8 引擎解析 JavaScript 脚本；
2) 解析后的代码，调用 Node API ；
3) _libuv 库_ 负责 Node API 的执行，它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给 V8 引擎；
4) V8 引擎再将结果返回给用户。

除了 setTimeout 和 setInterval 这两个方法， NodeJS 还提供了另外两个与“任务队列”有关的方法： =process.nextTick= 和 =setImmediate= 。

=process.nextTick= 方法可以在当前“执行栈”的尾部 -- 下一次事件循环（主线程读取“任务队列”）之前 -- 触发回调函数。也就是说，它指定的任务总是发生在 _所有异步任务之前_ 。 =setImmediate= 方法则是在当前“任务队列”的尾部添加事件，与 =setTimeout(fn, 0)= 很像。

来看一段示例代码，如下：

#+BEGIN_SRC js -n
  process.nextTick(function A() {
    console.log(1);
    process.nextTick(function B(){console.log(2);});
  });

  setTimeout(function timeout() {
    console.log('TIMEOUT FIRED');
  }, 0)
#+END_SRC

执行结果如下 ↓↓↓

#+BEGIN_EXAMPLE
  // → 1
  // → 2
  // → TIMEOUT FIRED
#+END_EXAMPLE

注意，由于 =process.nextTick= 方法指定的回调函数，总是在当前“执行栈”尾部触发，所以不仅函数 A 比 setTimeout 指定的回调函数 timeout 先执行，而且函数 B 也比 timeout 先执行。这说明，如果有多个 =process.nextTick= 语句，不管它们是否嵌套，将全部在当前“执行栈”执行。

** Stack 的三种含义[fn:4]

在上述章节中，我们多次提到 _执行栈_ ，那么 _栈（stack）_ 到底是什么呢？

_1. 数据结构_

→ [[https://www.rosecoder.com/data-structures-reference.html#orgdff7e2f][stack]]

stack 的第一种含义是一组数据的存放方式，特点是 _后进先出_ ，如下图：

#+BEGIN_EXPORT html
<img src="http://www.ruanyifeng.com/blogimg/asset/201311/bg2013112901.png" width="40%" />
#+END_EXPORT

与这种结构配套的，是一些特定的方法，如下：

#+BEGIN_EXAMPLE
- push → 在最顶层加入数据；
- pop → 返回并移除最顶层的数据；
- top → 返回最顶层的数据的值，但不移除它；
- isempty → 返回一个布尔值，表示当前 stack 是否为空栈。
#+END_EXAMPLE

_2. 代码运行方式_

stack 的第二种含义是“调用栈”（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。

来看一段 Java 示例代码，如下：

#+BEGIN_SRC java -n
  class Student {
      int age;
      String name;

      public Student(int Age, String Name) {
          this.age = Age;
          setName(Name);
      }

      public void setName(String Name) {
          this.name = Name;
      }
  }

  public class Main {
      public static void main(String[] args) {
          Student s;
          s = new Student(23, "John");
      }
  }
#+END_SRC

上面这段代码运行的时候，首先调用 =main= 方法，里面需要生成一个 =Student= 的实例，于是又调用 =Student= 构造函数。在构造函数中，又调用到 =setName= 方法。

#+BEGIN_EXPORT html
<img src="http://www.ruanyifeng.com/blogimg/asset/201311/bg2013112902.gif" width="60%" />
#+END_EXPORT

这三次调用像积木一样堆起来，就叫做“调用栈”。程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直到完成整个调用栈，返回最后的结果。

_3. 内存区域_

stack 的第三种含义是存放数据的一种内存区域。程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：栈（stack）和堆（heap）。它们的主要区别是：
- 栈（stack）是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；
- 堆（heap）是没有结构的，数据可以任意存放，寻址速度比栈慢；
- 每个线程分配一个 stack ，是线程独占的创建的时候。大小是确定的，数据超过这个大小，就发生 =stack overflow= 错误；
- 每个进程分配一个 heap ，是线程共用的。大小是不确定的，需要的话可以不断增加。

根据上面的这些区别，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在 stack 里面，否则就放在 heap 里面。

#+BEGIN_EXPORT html
<img src="http://www.ruanyifeng.com/blogimg/asset/201311/bg2013112905.jpg" width="60%" />
#+END_EXPORT

如图所示， =i= 、 =y= 和 =cls1= 都存放在 stack ，因为它们占用内存空间都是确定的，而且本身也属于局部变量。但是， =cls1= 指向的对象实例存放在 heap ，因为它的大小不确定。当 =Method1= 方法运行结束，整个 stack 会被清空， =i= 、 =y= 和 =cls1= 这三个变量小时，因为它们是局部变量，区块一旦结束，就没必要再存在了，而 heap 之中的那个对象实例继续存在，直到系统的垃圾清理机制（garbage collector）将这块内存回收。因此，一般来说，内存泄漏都发生在 heap ，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。

** NEXT JS 的异步编程方案[fn:5]

   - State "NEXT"       from "TODO"       [2020-01-23 Thu 09:31]

*** 回调函数

回调函数是异步操作最基本的方法，缺点是容易写出 _回调地狱_ ，如多个请求存在依赖性时，代码就会像下面这样：

#+BEGIN_SRC js -n
  ajax(url, () => {
      // todo....
      ajax(url1, () => {
          // todo....
          ajax(url2, () => {
              // todo....
          })
      })
  })
#+END_SRC

回调函数 _优点_ 是简单、容易理解和实现； _缺点_ 是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪，且每个任务只能指定一个回调函数，此外它不能使用 try catch 捕获错误，不能直接 return [fn:6]。

*** 事件监听

这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

假如想要实现函数 f2 必须等到 f1 执行完成，才能执行，可以这样做：
1) 为 f1 绑定一个事件 =done= ；
2) 当 f1 执行完成，触发事件 =done= 。

#+BEGIN_SRC js -n
  f1.on('done', f2);              // f1 绑定 done

  funtion f1() {
      setTimeout(() => {
          // todo....
          f1.trigger('done');     // 触发 done
      }, 1000)
  }

#+END_SRC

事件监听的 _优点_ 是比较容易理解，可以绑定 _多个_ 事件，每个事件可以指定 _多个_ 回调函数，而且可以“去耦合”，有利于实现模块化； _缺点_ 是整个程序都要变成事件驱动型，运行流程会变得不清晰，阅读代码的时候，很难看出主流程。

*** 发布订阅

我们假定，存在一个 “信号中心” ，某个任务执行完成，就向信号中心 _“发布”_ （publish）一个信号，其他任务可以向信号中心 _“订阅”_  (subscribe) 这个信号，从而知道什么时候自己可以开始执行。这就叫做 _“发布/订阅模式”_ （publish-subscribe pattern），又称为 “观察者模式” （observer pattern）。

同上，假如想要实现函数 f2 必须等到 f1 执行完成，才能执行，可以这样做：
1) f2 向信号中心 jQuery 订阅 =done= 信号；
2) f1 执行完成后，向信号中心 jQuery 发布 =done= 信号，从而引发 f2 执行；
3) f2 完成执行后，可以取消订阅（unsubscribe）。

#+BEGIN_SRC js -n
  jQuery.subscribe('done', f2);   // f2 订阅 done

  function f1() {
      setTimeout(() => {
          // ....
          jQuery.publish('done'); // f1 发布完成信号 done
      }, 1000);
  }

  // f1();
  // jQuery.unsubscribe('done', f2);
#+END_SRC

这种方法的性质与“事件监听”类似，但是明显优于后者，因为可以通过查看 “消息中心” ，了解存在到少信号、每个信号有多少订阅者，从而监控程序的运行。

*** Promise

Promise 在程序中的意思就是 _承诺_ 过一段时间后给你结果，用于异步操作，如网络请求、读取本地文件等。

Promise 的三种状态：
- Pending ，Promise 对象实例创建时候的 _初始状态_ ；
- Fulfilled ，可以理解为成功的状态 _resolved_ ；
- Rejected ，可以理解为失败的状态 _rejected_ 。

注意 **一旦从等待状态变成为其他状态就永远不能更改状态了** 。看段示例代码：

#+BEGIN_SRC js -n
  let p = new Promise((resolve, reject) => {
      reject('reject fail....');
      resolve('resolve success....'); // 无效代码不会执行
  })

  p.then(
      val => {
          console.log(val);
      },
      res => {
          console.log(res);           // → reject fail....
      }
  )
#+END_SRC

#+BEGIN_QUOTE
注意：在构造 Promise 的时候，构造函数内部的代码是 _立即执行_ 的。
#+END_QUOTE

_Promise 的链式调用_ ：
- 每次调用返回的都是一个新的 Promise 实例（这就是 then 可用链式调用的原因）；
- 如果 then 中返回的是一个结果的话，就把这个结果传递下一次 then 中的成功回调；
- 如果 then 中出现异常，会走下一个 then 的失败回调；
- *在 then 中使用了 return ，那么 _return 的值会被 =Promise.resolve()= 包装_* （见例 1，2）；
- then 中可以不传递参数，如果不传递会透到下一个 then 中（见例 3）；
- catch 会捕获到没有捕获的异常。

来看几段示例代码，如下：

#+BEGIN_SRC js -n
  // e.g.1
  Promise.resolve(1)
      .then(res => {
          console.log(res);
          return 2;               // 会被自动包装成 Promise.resolve(2)
      })
      .catch(err => 3)
      .then(res => console.log(res))
#+END_SRC

#+BEGIN_SRC js -n
  // e.g.2
  Promise.resolve(1)
      .then(x => x + 1)
      .then(x => {
          throw new Error('My Error')
      })
      .catch(() => 1)
      .then(x => x + 1)
      .then(x => console.log(x))  // 2
      .catch(console.error)
#+END_SRC

#+BEGIN_SRC js -n
  // e.g.3
  let fs = require('fs')

  function read(url) {
      return new Promise((resolve, reject) => {
          fs.readFile(url, 'utf8', (err, data) => {
              if(err) reject(err)
              resolve(data)
          })
      })
  }

  read('./name.txt')
      .then(
          data => throw new Error()                // then 中出现异常，会走下一个 then 的失败回调
      )                                            // 由于下一个 then 没有失败回调，就会继续往下找，如果没有，则被 catch 捕获
      .then( data => console.log('data....'))
      .then()
      .then(null, err => console.log('then', err)) // then ERROR
      .catch(err => console.log('error....'))
#+END_SRC

Promise 不仅能够捕获错误，而且也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：

#+BEGIN_SRC js -n
  ajax(url)
      .then(res => {
          console.log(res)
          return ajax(url1)
      })
      .then(res => {
          console.log(res)
          return ajax(url2)
      })
      .then(res => console.log(res))
#+END_SRC

它也是存在一些缺点的，比如无法取消 Promise ，错误需要通过回调函数捕获。

*** Gernerator

i.e. 生成器 Gernerators/yield

Gernerator 函数是 ES6 提供的一种异步编程方案，语法与传统函数完全不同，最大的 _特点_ 是可以控制函数的执行。
- 语法上，首先可以理解成， Gernerator 函数是一个 _状态机_ ，封装了多个内部状态；
- Gernerator 函数除了是状态机，还是一个 _遍历器对象生成函数_ ；
- 可暂停函数， =yield= 可暂停， =next= 方法可启动，每次返回的是 =yield= 后的表达式结果；
- =yield= 表达式本身没有返回值，或者说总是返回 =undefined= 。 =next= 方法可以带一个参数，该参数就会被当作上一个 =yield= 表达式的返回值。

来看一段代码示例：
#+BEGIN_SRC js -n
  function* foo(x) {
      let y = 2 * (yield (x + 1))
      let z = yield (y / 3)
      return (x + y + z)
  }

  let it = foo(5)

  console.log(it.next())          // => {value: 6,  done: false}
  console.log(it.next(12))        // => {value: 8,  done: false}
  console.log(it.next(13))        // => {value: 42, done: false}
#+END_SRC

可能结果和想象的不一致，我们来逐行分析一下上述代码：
- 首先 Generator 函数调用和普通函数不同，它会 _返回一个迭代器_ ；
- 当执行第一次 =next= 时，传参会被忽略，并且函数暂停在 =yield (x + 1)= 处，所以返回 =5 + 1 = 6= ；
- 当执行第二次 =next= 时，传入的参数 =12= 就会被当作上一个 =yield= 表达式的返回值，如果不传参， yield 永远返回 =undefined= 。此时 =let y = 2 * 12= ，所以第二个 =yield=  等于 =2 * 12 / 3 = 8= ；
- 当执行第三次 =next= 时，传入的参数 =13= 就会被当作上一个 =yield= 表达式的返回值，所以 =z = 13, x = 5, y = 24= ，相加等于 =42= 。

再来看一个例子，假如有三个本地文件，名称及内容如下：

#+BEGIN_EXAMPLE
  # 1.txt
  2.txt                           # 内容

  # 2.txt
  3.txt                           # 内容

  # 3.txt
  结束                            # 内容
#+END_EXAMPLE

下一个请求依赖上一个请求的结果，想通过 Generator 函数依次调用三个文件。

#+BEGIN_SRC js -n
  let fs = require('fs')

  function read(file) {
      return new Promise((resolve, reject) => {
          fs.readFile(file, 'utf8', (err, data) => {
              if(err) reject(err)
              resolve(data)
          })
      })
  }

  function* r() {
      let r1 = yield read('./1.txt')
      let r2 = yield read(r1)
      let r3 = yield read(r2)
      console.log(r1)
      console.log(r2)
      console.log(r3)
  }

  let it = r()
  let {value, done} = it.next()   // value 是一个 promise

  value.then(data => {
      console.log(data)           // data → 2.txt

      let {value, done} = it.next(data)
      value.then(data => {
          console.log(data)       // data → 3.txt'

          let {value, done} = it.next(data)
          value.then(data => {
              console.log(data)   // data → 结束
          })
      })
  })

  // → 2.txt
  // → 3.txt
  // → 结束
#+END_SRC

从上面的例子中，可以看出手动迭代 Generator 函数是很麻烦的，逻辑实现有点绕。实际开发中，一般会引入并配置 _co 库_ -- 一个为 NodeJS 和浏览器打造的基于生成器的流程控制工具，借助于 Promise ，可以使用更加优雅的方式编写非阻塞代码。

我们引入 co 库，对上述代码进行改造，如下：

#+BEGIN_SRC js -n
  function* r() {
      let r1 = yield read('./1.txt')
      let r2 = yield read(r1)
      let r3 = yield read(r2)
      console.log(r1)
      console.log(r2)
      console.log(r3)
  }

  let co = require('co')                  // 引入 co 库
  co(r()).then(data => console.log(data))

  // → 2.txt
  // → 3.txt
  // → 结束
  // → undefined
#+END_SRC

我们可以通过 Generator 函数解决回调地狱的问题，把之前的回调地狱的例子用 Generator 函数改写，如下：

#+BEGIN_SRC js -n
  function* fetch() {
      yield ajax(url,  () => {})
      yield ajax(url1, () => {})
      yield ajax(url2, () => {})
  }

  let it = fetch()
  let result1 = it.next()
  let result2 = it.next()
  let result3 = it.next()
#+END_SRC

*** Async/Await

_1. Async/Await 简介_

使用 async/await ，你可以轻松地达成之前使用 Generator 和 co 函数所做地工作，它有如下特点：
- async/await 是基于 Promise 实现的，它不能用于普通地回调函数；
- async/await 与 Promise 一样，是非阻塞的；
- async/await 使得一部代码看起来像同步代码，这正是它的魔力所在。

*一个函数如果加上 async ，那么该函数就会返回一个 Promise 。*

#+BEGIN_SRC js -n
  async function async1() {
      return '1'
  }

  console.log(async1())           // → Promise {<resolved>: '1'}
#+END_SRC

Generator 函数依次调用三个文件那个例子使用 async/await 写法改写，如下：

#+BEGIN_SRC js -n
  let fs = require('fs')

  function read(file) {
      return new Promise((resolve, reject) => {
          fs.readFile(file, 'utf8', (err, data) => {
              if(err) reject(err)
              resolve(data)
          })
      })
  }

  async function readResult(params) {
      try {
          let p1 = await read(params, 'utf8') // await 后面跟的是一个 Promise 实例
          let p2 = await read(p1, 'utf8')
          let p3 = await read(p2, 'utf8')
          console.log('p1', p1)
          console.log('p2', p2)
          console.log('p3', p3)

          return p3
      } catch (err) {
          console.log(err)
      }
  }

  readResult('1.txt')
      .then(
          data => console.log(data),
          err  => console.log(err)
      )
  // p1 2.txt
  // p2 3.txt
  // p3 结束
  // 结束
#+END_SRC

_2. Async/Await 并发请求_

如果请求两个文件，可以通过并发请求：

#+BEGIN_SRC js -n
  let fs = require('fs')

  function read(file) {
      return new Promise((resolve, reject) => {
          fs.readFile(file, 'utf8', (err, data) => {
              if(err) reject(err)
              resolve(data)
          })
      })
  }

  function readAll() {
      read1()
      read2()                     // 这个函数同步执行
  }

  async function read1() {
      let r = await read('1.txt', 'utf8')
      console.log(r)
  }

  async function read2() {
      let r = await read('2.txt', 'utf8')
      console.log(r)
  }

  readAll()
  // → 2.txt
  // → 3.txt
#+END_SRC

** 总结

JavaScript 异步编程进化史： callback → promise → generator → async + await 。

async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。

async/await 可以说是异步终极解决方案了，相对于 Promise ， _优势_ 体现在：
- 处理 then 的调用链，能够更清晰准确的写出代码；
- 并且也能优雅地解决回调地狱问题。

当然 async/await 函数也存在一些 _缺点_ ，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。

async/await 函数对 Generator 函数的改进，体现在一下三点：

_1. 内置执行器_

Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说， async 函数的执行，与普通函数一模一样，只要一行。

_2. 更广的实用性_

co 函数库约定， yield 命令后面指能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等于同步操作）。

_3. 更好的语义_

async 和 await ，比起星号 =*= 和 =yield= ，语义更清楚了。 async 表示函数里有异步操作， await 表示紧跟在后面的表达式需要等待结果。

* Footnotes

[fn:6] https://blog.csdn.net/u011374582/article/details/83069764

[fn:5] https://github.com/ljianshu/Blog/issues/53

[fn:4] http://www.ruanyifeng.com/blog/2013/11/stack.html

[fn:3] https://juejin.im/post/59e85eebf265da430d571f89

[fn:2] http://vimeo.com/96425312

[fn:1] http://www.ruanyifeng.com/blog/2014/10/event-loop.html
