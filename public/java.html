<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-05-02 Sat 09:09 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" href="/css/animate.min.css" />
<link rel="stylesheet" href="/css/all.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script src="/js/jquery.min.js"></script>
<script src="/js/darkreader.js"></script>
<script src="/js/main.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">Java</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org96e8275">介绍</a></li>
<li><a href="#orgd552573">Java 基础知识</a>
<ul>
<li><a href="#orgf75fe0b">数据类型</a></li>
<li><a href="#orgd7b6bf2">类型初始化</a>
<ul>
<li><a href="#orgf59ef40">数组</a></li>
</ul>
</li>
<li><a href="#org7889fe2">数组的操作</a></li>
<li><a href="#orgcba3dd6">命令行参数</a></li>
</ul>
</li>
<li><a href="#orgdd97251">Java 数据结构</a>
<ul>
<li><a href="#org2ff8fb4">枚举</a></li>
<li><a href="#orga1c3a46">位集合</a></li>
<li><a href="#org8f44bc7">向量</a></li>
<li><a href="#orgc7967b1">栈</a></li>
<li><a href="#orgb1e3e11">字典</a></li>
<li><a href="#org4f908e9">Map 接口</a></li>
<li><a href="#org0315630">哈希表</a></li>
<li><a href="#org3797a8e">属性</a></li>
</ul>
</li>
<li><a href="#org4f074cc">Java 面向对象</a>
<ul>
<li><a href="#orgecdebb0">类的属性和方法</a></li>
<li><a href="#org2f65293">类的构造方法</a></li>
<li><a href="#org0f42c84">方法重载</a></li>
<li><a href="#org2d9b977">继承</a></li>
<li><a href="#org30d90d6">多态</a></li>
<li><a href="#org1cb678e">抽象类和接口</a></li>
<li><a href="#org35cb7d5">静态字段和静态方法</a></li>
<li><a href="#org5122a18">包</a></li>
<li><a href="#org785af7d">作用域</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org96e8275" class="outline-2">
<h2 id="org96e8275">介绍</h2>
<div class="outline-text-2" id="text-org96e8275">
<p>
Java 学习路线如下：
</p>
<ul class="org-ul">
<li>Java SE ，掌握 Java 语言核心、 Java 核心开发技术以及 Java 标准库的使用；</li>
<li>Java EE ，需要学习 Spring 框架、数据库开发、分布式架构；</li>
<li>大数据开发，需要学习 Hadoop、Spark、Flink 等大数据平台；</li>
<li>移动开发，需要学习 Android 平台开发。</li>
</ul>

<p>
例行，先输出 <code>Hello World.</code> ，看代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">Hello.java</span>
<span class="linenr">2: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Hello</span><span style="color: #AE81FF;">{</span>
<span class="linenr">3: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">4: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Hello World."</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">5: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">6: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
如何运行 Java 程序？
</p>

<div class="figure">
<p><img src="../images/java/run-process.jpg" alt="run-process.jpg">
</p>
</div>
</div>
</div>

<div id="outline-container-orgd552573" class="outline-2">
<h2 id="orgd552573">Java 基础知识</h2>
<div class="outline-text-2" id="text-orgd552573">
<p>
Java 是面向对象的语言，一个程序的 <span class="underline">基本单位</span> 就是 <code>class</code> ，可以这样理解，Java 的所有数据和逻辑都是 <b><b>封装</b></b> 在 class 中的。
</p>
</div>

<div id="outline-container-orgf75fe0b" class="outline-3">
<h3 id="orgf75fe0b">数据类型</h3>
<div class="outline-text-3" id="text-orgf75fe0b">
<p>
在 Java 中，变量分为两种：基本类型、引用类型，必须 <span class="underline">先定义后使用</span> ，类型不能重复定义。
</p>

<p>
什么是基本数据类型呢？基本数据类型是 CPU 可以直接进行运算的类型，Java 定义了一下集中基本数据类型：
</p>
<ul class="org-ul">
<li>整数类型： byte、short、int、long ；</li>
<li>浮点类型： float、double ；</li>
<li>字符类型： char ；</li>
<li>布尔类型： boolean 。</li>
</ul>

<p>
Java 基本数据类型占用的字节数，如下：
</p>

<div class="figure">
<p><img src="../images/java/primitive-type.jpg" alt="primitive-type.jpg">
</p>
</div>

<p>
<code>byte</code> 恰好就是一个字节，等于 8 个 <code>bit</code> 。
</p>

<p>
<b><b>字符串数据类型</b></b> 需要注意什么？
</p>

<p>
Java 的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。对字符串变量重新赋值，其实是 JVM 另外开辟了一个空间，然后把变量指向它。
</p>

<p>
<b><b>数组</b></b> 有几个特点？如下：
</p>
<ul class="org-ul">
<li>数组所有元素初始化为默认值，整型都是 <code>0</code> ，浮点型是 <code>0.0</code> ，布尔型是 <code>false</code> ；</li>
<li>数组一旦创建后，大小就不可变。</li>
</ul>

<p>
如何初始化数组呢？通过 new 初始化或直接指定初始化的元素或字面量初始化，如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Main</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">new &#21021;&#22987;&#21270;&#65292;&#21518;&#36890;&#36807;&#32034;&#24341;&#36171;&#20540;</span>
<span class="linenr"> 4: </span>        <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">arr</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">[</span>5<span style="color: #A6E22E;">]</span>;
<span class="linenr"> 5: </span>        arr<span style="color: #A6E22E;">[</span>0<span style="color: #A6E22E;">]</span> = 11;
<span class="linenr"> 6: </span>        arr<span style="color: #A6E22E;">[</span>1<span style="color: #A6E22E;">]</span> = 22;
<span class="linenr"> 7: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr"> 8: </span>        arr<span style="color: #A6E22E;">[</span>4<span style="color: #A6E22E;">]</span> = 55;
<span class="linenr"> 9: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32034;&#24341;&#36229;&#20986;&#33539;&#22260;&#65292;&#36816;&#34892;&#26102;&#23558;&#25253;&#38169;</span>
<span class="linenr">10: </span>        arr<span style="color: #A6E22E;">[</span>5<span style="color: #A6E22E;">]</span> = ...
<span class="linenr">11: </span>
<span class="linenr">12: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#30452;&#25509;&#25351;&#23450;&#21021;&#22987;&#21270;&#30340;&#20803;&#32032;</span>
<span class="linenr">13: </span>        <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">[]</span> _arr = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">[]</span> <span style="color: #A6E22E;">{</span> 1, 2, 3, 4, 5 <span style="color: #A6E22E;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23383;&#38754;&#37327;&#21021;&#22987;&#21270;</span>
<span class="linenr">16: </span>        <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">__arr</span> = <span style="color: #A6E22E;">{</span> 1, 2, 3, 4, 5 <span style="color: #A6E22E;">}</span>;
<span class="linenr">17: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">18: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<blockquote>
<p>
注意：后续代码片段如果没有写类名，默认都写在含有 <code>main</code> 方法的类中。
</p>
</blockquote>

<p>
关于 <b><b>字符串数组</b></b> ，应该知道？
</p>

<p>
如果数组元素不是基本类型，而是一个引用类型，其实数组的元素实际上是引用类型的 <b><b>引用地址</b></b> 。
</p>
</div>
</div>

<div id="outline-container-orgd7b6bf2" class="outline-3">
<h3 id="orgd7b6bf2">类型初始化</h3>
<div class="outline-text-3" id="text-orgd7b6bf2">
</div>
<div id="outline-container-orgf59ef40" class="outline-4">
<h4 id="orgf59ef40">数组</h4>
<div class="outline-text-4" id="text-orgf59ef40">
<p>
<span class="underline">1. 声明数组变量</span>
</p>

<pre class="example">
dataType[] arrayRefVar;         // 首选方法
// OR
dataType arrayRefVar[];         // C/C++ 风格，效果相同（不推荐）
</pre>
<p>
↓
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">myList</span>;                <span style="color: #75715E;">// </span><span style="color: #75715E;">&#39318;&#36873;&#26041;&#27861;</span>
<span class="linenr">2: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">OR</span>
<span class="linenr">3: </span><span style="color: #66D9EF;">double</span> <span style="color: #FD971F;">myList</span><span style="color: #AE81FF;">[]</span>;                <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25928;&#26524;&#30456;&#21516;&#65288;&#19981;&#25512;&#33616;&#65289;</span>
</pre>
</div>

<p>
<span class="underline">2. 创建数组</span>
</p>

<pre class="example">
dataType[] arrayRefVar;                // 声明数组变量 arrayRefVar
arrayRefVar = new dataType[arraySize]; // 创建数组，然后赋值给声明的数组变量 arrayRefVar

// new 创建数组 → 声明变量 → 赋值数组给声明的变量
dataType[] arrayRefVar = new dataType[arraySize];
// OR
dataType[] arrayRefvar = new dataType[]{ value0, value1, ..., valuek };

// 字面量方式创建数组 → 声明数组变量 → 赋值数组给声明的变量
dataType[] arrayRefVar = { value0, value1, ..., valuek};
</pre>
<p>
↓
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">myList</span>;                <span style="color: #75715E;">// </span><span style="color: #75715E;">&#22768;&#26126;&#25968;&#32452;&#21464;&#37327; myList</span>
<span class="linenr"> 2: </span>myList = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">dataType</span><span style="color: #AE81FF;">[</span>9<span style="color: #AE81FF;">]</span>;       <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21019;&#24314;&#25968;&#32452;&#65288;&#38271;&#24230;&#20026; 9&#65289;&#65292;&#24182;&#36171;&#20540;&#32473;&#21464;&#37327; myList</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">new &#36816;&#31639;&#31526;</span>
<span class="linenr"> 5: </span><span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">myList</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[</span>9<span style="color: #AE81FF;">]</span>;
<span class="linenr"> 6: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">OR</span>
<span class="linenr"> 7: </span><span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">myList</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[]{</span> 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #AE81FF;">}</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#23383;&#38754;&#37327;</span>
<span class="linenr">10: </span><span style="color: #66D9EF;">double</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">myList</span> = <span style="color: #AE81FF;">{</span> 1, 2, 3, 4, 5, 6, 7, 8, 9 <span style="color: #AE81FF;">}</span>;
</pre>
</div>

<p>
<span class="underline">3. 多维数组</span>
</p>

<pre class="example">
type[][] typeName = new type[typeLength1][typeLength2];
</pre>
<p>
↓
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">str</span><span style="color: #AE81FF;">[][]</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">String</span><span style="color: #AE81FF;">[</span>3<span style="color: #AE81FF;">][</span>4<span style="color: #AE81FF;">]</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#19977;&#34892;&#22235;&#21015;&#30340;&#25968;&#32452;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7889fe2" class="outline-3">
<h3 id="org7889fe2">数组的操作</h3>
<div class="outline-text-3" id="text-org7889fe2">
<p>
Java 中的数组的操作，包括：遍历、排序。
</p>

<p>
如何遍历一个数组呢？
</p>
<ul class="org-ul">
<li>通过 <code>for</code> 循环可以；</li>
<li>通过 <code>for each</code> 循环，可以迭代数组的每个元素，但无法拿到数组的索引。</li>
</ul>

<blockquote>
<p>
使用 <code>Arrarys.toString()</code> 可以快速获取数组内容。
</p>
</blockquote>

<p>
如何排序一个数组呢？常用的排序算法有：
</p>
<ul class="org-ul">
<li>冒泡排序；</li>
<li>插入排序；</li>
<li>快速排序。</li>
</ul>

<blockquote>
<p>
Java 的标准库已经内置了排序功能，只需要调用 JDK 提供的 <code>Arrays.sort()</code> 就可以排序。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgcba3dd6" class="outline-3">
<h3 id="orgcba3dd6">命令行参数</h3>
<div class="outline-text-3" id="text-orgcba3dd6">
<p>
Java 程序的入口是 <code>main</code> 方法，儿 <code>main</code> 方法可以接受一个命令行参数，它是一个 <code>String[]</code> 数组。这个命令行参数由 JVM 接收用户输入并传给 <code>main</code> 方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Main</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">3: </span>        <span style="color: #F92672;">for</span><span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">arg</span>: args<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">4: </span>            System.out.println<span style="color: #E6DB74;">(</span>arg<span style="color: #E6DB74;">)</span>;
<span class="linenr">5: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">6: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">7: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码，如实现一个 <code>-version</code> 参数，打印程序版本号：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr">2: </span><span style="color: #F92672;">for</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">arg</span>: args<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">3: </span>    <span style="color: #F92672;">if</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"-version"</span>.equals<span style="color: #A6E22E;">(</span>arg<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">4: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"v 1.0"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">5: </span>        <span style="color: #F92672;">break</span>;
<span class="linenr">6: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">7: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">8: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdd97251" class="outline-2">
<h2 id="orgdd97251">Java 数据结构</h2>
<div class="outline-text-2" id="text-orgdd97251">
<p>
→ <a href="https://www.runoob.com/java/java-data-structures.html">Java Data Structures</a>
</p>

<p>
Java 工具包提供了强大的数据结构，主要包括一下几种接口和类：枚举、位集合、向量、栈、字典、哈希表、属性、集合框架（Java2 引入）。
</p>
</div>

<div id="outline-container-org2ff8fb4" class="outline-3">
<h3 id="org2ff8fb4">枚举</h3>
<div class="outline-text-3" id="text-org2ff8fb4">
<p>
i.e.Enumberation
</p>

<p>
<span class="underline">枚举接口</span> 本身 <span class="underline">不属于</span> 数据结构，但它在其他数据结构的范畴里应用很广，它定义了一种从数据结构中 <span class="underline">取回连续元素</span> 的方式。
</p>

<blockquote>
<p>
枚举接口定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。这种传统接口已被 <span class="underline">迭代器</span> 取代，虽然枚举接口还未遗弃，但在现代代码中已经很少使用了。尽管如此，它还是在注入 Vector 和 Properties 这些传统类所定义的方法中，除此之外，还用在一些 API 类，并且在应用程序中也广泛被使用。
</p>
</blockquote>

<table>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>boolean hasMoreElements()</code></td>
<td class="org-left">测试此枚举是否包含更多的元素</td>
</tr>

<tr>
<td class="org-left"><code>Object nextElement()</code></td>
<td class="org-left">如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">util</span>.<span style="color: #66D9EF;">Vector</span>;
<span class="linenr"> 2: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">util</span>.<span style="color: #66D9EF;">Enumberation</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">EnumberationTester</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 5: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #66D9EF;">Enumberation</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">days</span>;
<span class="linenr"> 7: </span>        <span style="color: #66D9EF;">Vector</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">dayNames</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Vector</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;()</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Sunday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">10: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Monday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">11: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Tuesday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Wednesday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">13: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Thursday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">14: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Friday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">15: </span>        dayNames.add<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Saturday"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>        days = dayNames.elements<span style="color: #A6E22E;">()</span>;
<span class="linenr">18: </span>
<span class="linenr">19: </span>        <span style="color: #F92672;">while</span><span style="color: #A6E22E;">(</span>days.hasMoreElements<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">20: </span>            System.out.println<span style="color: #E6DB74;">(</span>days.nextElement<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">21: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">22: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">23: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">24: </span>
<span class="linenr">25: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Sunday</span>
<span class="linenr">26: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Monday</span>
<span class="linenr">27: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Tuesday</span>
<span class="linenr">28: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Wednesday</span>
<span class="linenr">29: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Thursday</span>
<span class="linenr">30: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Friday</span>
<span class="linenr">31: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; Saturday</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1c3a46" class="outline-3">
<h3 id="orga1c3a46">位集合</h3>
<div class="outline-text-3" id="text-orga1c3a46">
<p>
i.e. BitSet
</p>

<p>
一个 Bitset 类创建一种特殊类型的数组来 <span class="underline">保存位值</span> ，BitSet 中数组大小会随需要增加，和位向量（vector of bits）比较类似，在 Java2 中被完全重新设计，它定义了两个构造方法。
</p>

<pre class="example">
BitSet()                        // 1 → 创建一个默认的对象
BitSet(int size)                // 2 → 允许用户指定初始大小，所有位初始化为 0
</pre>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">util</span>.<span style="color: #66D9EF;">BitSet</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">BitSetDemo</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 4: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 5: </span>        <span style="color: #66D9EF;">BitSet</span> <span style="color: #FD971F;">bits1</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BitSet</span><span style="color: #A6E22E;">(</span>16<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 6: </span>        <span style="color: #66D9EF;">BitSet</span> <span style="color: #FD971F;">bits2</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BitSet</span><span style="color: #A6E22E;">(</span>16<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">set some bits</span>
<span class="linenr"> 9: </span>        <span style="color: #F92672;">for</span><span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span> = 0; i &lt; 16; i++<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">10: </span>            <span style="color: #F92672;">if</span><span style="color: #E6DB74;">(</span><span style="color: #FD971F;">(</span>i % 2<span style="color: #FD971F;">)</span> == 0<span style="color: #E6DB74;">)</span> bits1.set<span style="color: #E6DB74;">(</span>i<span style="color: #E6DB74;">)</span>;
<span class="linenr">11: </span>            <span style="color: #F92672;">if</span><span style="color: #E6DB74;">(</span><span style="color: #FD971F;">(</span>i % 5<span style="color: #FD971F;">)</span> != 0<span style="color: #E6DB74;">)</span> bits2.set<span style="color: #E6DB74;">(</span>i<span style="color: #E6DB74;">)</span>;
<span class="linenr">12: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span>        System.out.println<span style="color: #A6E22E;">(</span>bits1<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; {0, 2, 4, 6, 8, 10, 12, 14}</span>
<span class="linenr">15: </span>        System.out.println<span style="color: #A6E22E;">(</span>bits2<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; {1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">AND bits</span>
<span class="linenr">18: </span>        bits2.and<span style="color: #A6E22E;">(</span>bits1<span style="color: #A6E22E;">)</span>;
<span class="linenr">19: </span>        System.out.println<span style="color: #A6E22E;">(</span>bits2<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; {2, 4, 6, 8, 12, 14}</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">OR bits</span>
<span class="linenr">22: </span>        bits2.or<span style="color: #A6E22E;">(</span>bits1<span style="color: #A6E22E;">)</span>;
<span class="linenr">23: </span>        System.out.println<span style="color: #A6E22E;">(</span>bits2<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; {0, 2, 4, 6, 8, 10, 12, 14}</span>
<span class="linenr">24: </span>
<span class="linenr">25: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">XOR bits</span>
<span class="linenr">26: </span>        bits2.xor<span style="color: #A6E22E;">(</span>bits1<span style="color: #A6E22E;">)</span>;
<span class="linenr">27: </span>        System.out.println<span style="color: #A6E22E;">(</span>bits2<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; {}</span>
<span class="linenr">28: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">29: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
其中，关于 set ，大致用法如下：
</p>
<table>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>void set(int index)</code></td>
<td class="org-left">指定索引处的位为 <span class="underline">true</span></td>
</tr>

<tr>
<td class="org-left"><code>void set(int index, boolean v)</code></td>
<td class="org-left">指定索引处的位为 <span class="underline">指定的值</span></td>
</tr>

<tr>
<td class="org-left"><code>void set(int startIndex, int endIndex)</code></td>
<td class="org-left">指定索引范围的位为 <span class="underline">true</span></td>
</tr>

<tr>
<td class="org-left"><code>void set(int startIndex, int endIndex, boolean v)</code></td>
<td class="org-left">指定索引范围的位为 <span class="underline">指定的值</span></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8f44bc7" class="outline-3">
<h3 id="org8f44bc7">向量</h3>
<div class="outline-text-3" id="text-org8f44bc7">
<p>
i.e. Vector
</p>

<p>
向量类和传统数组非常相似，但是 Vector 的大小能根据需要动态的变化。
</p>

<p>
Vector 类实现了一个动态数组，和 ArrayList 很相似，区别在于：
</p>
<ul class="org-ul">
<li>Vector 是同步访问的；</li>
<li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li>
</ul>

<p>
Vector 类支持 4 种构造方法，如下：
</p>

<pre class="example">
Vector()                        // 1 → 创建一个默认的向量，默认大小为 10
Vector(int size)                // 2 → 创建指定大小的向量
Vector(int size, int incr)      // 3 → 创建指定大小的向量，且指定增量 incr
Vertor(Collection c)            // 4 → 创建一个包含集合 c 元素的向量
</pre>
</div>
</div>

<div id="outline-container-orgc7967b1" class="outline-3">
<h3 id="orgc7967b1">栈</h3>
<div class="outline-text-3" id="text-orgc7967b1">
<p>
i.e. Stack
</p>

<p>
栈是 Vector 的一个子类，它实现了一个标准的后进先出的栈。
</p>

<p>
堆栈只定义了默认构造函数，用来创建一个空栈。
</p>

<pre class="example">
Stack()                         // 创建一个空栈
</pre>

<p>
除了由 Vector 定义的所有方法，Stack 也定义了一些方法：
</p>

<table>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>boolean empty()</code></td>
<td class="org-left">测试堆栈是否为空</td>
</tr>

<tr>
<td class="org-left"><code>Object peek()</code></td>
<td class="org-left">查看堆栈顶部的对象</td>
</tr>

<tr>
<td class="org-left"><code>Object pop()</code></td>
<td class="org-left">移除并返回堆栈顶部的对象</td>
</tr>

<tr>
<td class="org-left"><code>Object push(Object element)</code></td>
<td class="org-left">把像压入堆栈顶部</td>
</tr>

<tr>
<td class="org-left"><code>int search(Object element)</code></td>
<td class="org-left">返回对象在堆栈种的位置，以 1 为基数</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">util</span>.*;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">StackDemo</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 4: </span>    <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">showpush</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">Stack</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Integer</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">st</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">a</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 5: </span>        st.push<span style="color: #A6E22E;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Integer</span><span style="color: #E6DB74;">(</span>a<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 6: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"push("</span> + a + <span style="color: #E6DB74;">")"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 7: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"stack: "</span> + st<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 8: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">showpop</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">Stack</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Integer</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">st</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">11: </span>        System.out.print<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"pop -&gt; "</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>        <span style="color: #66D9EF;">Integer</span> <span style="color: #FD971F;">a</span> = <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">Integer</span><span style="color: #A6E22E;">)</span> st.pop<span style="color: #A6E22E;">()</span>;
<span class="linenr">13: </span>        System.out.println<span style="color: #A6E22E;">(</span>a<span style="color: #A6E22E;">)</span>;
<span class="linenr">14: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"stack: "</span> + st<span style="color: #A6E22E;">)</span>;
<span class="linenr">15: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">18: </span>        <span style="color: #66D9EF;">Stack</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Integer</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">st</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Stack</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Integer</span><span style="color: #A6E22E;">&gt;()</span>;
<span class="linenr">19: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"stack: "</span> + st<span style="color: #A6E22E;">)</span>;    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; stack: [ ]</span>
<span class="linenr">20: </span>        showpush<span style="color: #A6E22E;">(</span>st, 42<span style="color: #A6E22E;">)</span>;                      <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; push(42)  stack: [42]</span>
<span class="linenr">21: </span>        showpush<span style="color: #A6E22E;">(</span>st, 66<span style="color: #A6E22E;">)</span>;                      <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; push(66)  stack: [42, 66]</span>
<span class="linenr">22: </span>        showpush<span style="color: #A6E22E;">(</span>st, 99<span style="color: #A6E22E;">)</span>;                      <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; push(99)  stack: [42, 66, 99]</span>
<span class="linenr">23: </span>        showpop<span style="color: #A6E22E;">(</span>st<span style="color: #A6E22E;">)</span>;                           <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; pop -&gt; 99 stack: [42, 66]</span>
<span class="linenr">24: </span>        showpop<span style="color: #A6E22E;">(</span>st<span style="color: #A6E22E;">)</span>;                           <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; pop -&gt; 66 stack: [42]</span>
<span class="linenr">25: </span>        showpop<span style="color: #A6E22E;">(</span>st<span style="color: #A6E22E;">)</span>;                           <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; pop -&gt; 42 stack: [ ]</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>        <span style="color: #F92672;">try</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">28: </span>            showpop<span style="color: #E6DB74;">(</span>st<span style="color: #E6DB74;">)</span>;
<span class="linenr">29: </span>        <span style="color: #A6E22E;">}</span> <span style="color: #F92672;">catch</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">EmptyStackException</span> <span style="color: #FD971F;">e</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">30: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"empty stack"</span><span style="color: #E6DB74;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; pop -&gt; empty stack</span>
<span class="linenr">31: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">32: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">33: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">34: </span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1e3e11" class="outline-3">
<h3 id="orgb1e3e11">字典</h3>
<div class="outline-text-3" id="text-orgb1e3e11">
<p>
i.e. Dictionary
</p>

<p>
字典是一个抽象类，用来存储键/值对，作用和 Map 类相似，它定义了键映射到值得数据结构，但没有提供特定的实现。当你想要通过特定的键，而不是整数索引来访问数据的时候，应该使用字典。
</p>

<blockquote>
<p>
Dictionary 类已经过时了，在实际开发中，可以实现 Map 接口来获取键/值的存储功能。
</p>
</blockquote>

<p>
让我们看一下 <a href="#org4f908e9">Map 接口</a> ↓
</p>
</div>
</div>

<div id="outline-container-org4f908e9" class="outline-3">
<h3 id="org4f908e9">Map 接口</h3>
<div class="outline-text-3" id="text-org4f908e9">
<p>
Map 接口中键和值一一映射，可以通过键来获取值：
</p>
<ul class="org-ul">
<li>给定一个键和一个值，你可以将该值存储在一个 Map 对象，之后，可以通过键来访问对应的值；</li>
<li>当访问的值不存在的时候，方法就会抛出一个 <code>NoSuchElementException</code> 异常；</li>
<li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 <code>ClassCastException</code> 异常；</li>
<li>当在不允许使用 <code>Null</code> 对象的 Map 中使用 Null 对象，会抛出一个 <code>NullPointerException</code> 异常；</li>
<li>当尝试修改一个只读的 Map 时，会抛出一个 <code>UnsupportedPerationException</code> 异常。</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">util</span>.*;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">CollectionsDemo</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 4: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 5: </span>        <span style="color: #66D9EF;">Map</span> <span style="color: #FD971F;">m1</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashMap</span><span style="color: #A6E22E;">()</span>;
<span class="linenr"> 6: </span>        m1.put<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Zara"</span>, <span style="color: #E6DB74;">"8"</span><span style="color: #A6E22E;">)</span>;    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; &#23558;&#25351;&#23450;&#30340;&#20540;&#19982;&#38190;&#20851;&#32852;</span>
<span class="linenr"> 7: </span>        m1.put<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Mahnaz"</span>, <span style="color: #E6DB74;">"31"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 8: </span>        m1.put<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Ayan"</span>, <span style="color: #E6DB74;">"12"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 9: </span>        System.out.println<span style="color: #A6E22E;">(</span>m1<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; { Ayan=12, Zara=8, Mahnaz=31}</span>
<span class="linenr">10: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">11: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0315630" class="outline-3">
<h3 id="org0315630">哈希表</h3>
<div class="outline-text-3" id="text-org0315630">
<p>
i.e. HashTable
</p>

<blockquote>
<p>
Hashtable 类提供了一种在用户定义键构的基础上来组织数据的手段。例如，在地址列表的哈希表中，可以根据邮政编码作为存储和排序数据，而不是通过人名。哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。
</p>
</blockquote>

<p>
Hashtable 时原始的 <code>java.util</code> 的一部分，是一个 Dictionary 具体的实现。然而， Java2 重构的 Hashtable 实现了 Map 接口，因此，Hashtable 现在集成到了集合框架中。它和 HashMap 类很相似，但是它支持同步。
</p>

<p>
像 HashMap 一样， Hashtable 在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。
</p>

<p>
Hashtable 定义了四个构造方法，如下：
</p>

<pre class="example">
Hashtable()                             // 1 → 默认构造方法
Hashtable(int size)                     // 2 → 创建指定大小的哈希表
Hashtable(int size, float fillRatio)    // 3 → 创建一个指定大小的哈希表，并通过 fillRatio 指定填充比例（0.0 ~ 1.0）
Hashtable(Map m)                        // 4 → 创建一个以 M 中元素为初始化元素的哈希表，容量设置为 M 的两倍
</pre>
</div>
</div>

<div id="outline-container-org3797a8e" class="outline-3">
<h3 id="org3797a8e">属性</h3>
<div class="outline-text-3" id="text-org3797a8e">
<p>
i.e. Properties
</p>

<p>
Properties 继承于 Hashtable.Properties 类表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串，它被许多 Java 类使用，如获取环境变量时它就作为 <code>System.getProperties()</code> 方法的返回值。
</p>

<p>
Properties 定义如下实例变量，这个实例变量持有一个 Properties 对象相关的默认属性列表。
</p>

<pre class="example">
Properties defaults;
</pre>

<p>
Properties 类定义了两个构造方法，如下：
</p>

<pre class="example">
Properties()                       // 默认构造方法，没有默认值
Properties(Properties propDefault) // 使用 propDefault 作为默认值
</pre>
</div>
</div>
</div>

<div id="outline-container-org4f074cc" class="outline-2">
<h2 id="org4f074cc">Java 面向对象</h2>
<div class="outline-text-2" id="text-org4f074cc">

<div class="figure">
<p><img src="../images/java/oop.jpg" alt="oop.jpg">
</p>
</div>

<p>
<b><b>面向对象</b></b> 是什么？面向对象，是一种对现实世界理解和抽象的方法，它把相关的数据和方法组织为一个整体看待，更贴近事物的自然运行模式。
</p>

<p>
面向对象有三大特点：
</p>
<ol class="org-ol">
<li>封装；</li>
<li>继承；</li>
<li>多态。</li>
</ol>

<p>
基于三大特点，来区分两组易混淆的概念：
</p>
<ul class="org-ul">
<li>面向对象和面向过程；</li>
<li>面向对象和基于对象。</li>
</ul>

<blockquote>
<p>
浅谈“面向对象”：
</p>
<ul class="org-ul">
<li>对象，是一种抽象，描述事物的状态和行为；</li>
<li>封装，抽象对象为类的属性和方法；</li>
<li>继承，复用类的属性和方法；</li>
<li>多态，实际是哪个类，就用哪个类的方法。</li>
</ul>
</blockquote>
</div>

<div id="outline-container-orgecdebb0" class="outline-3">
<h3 id="orgecdebb0">类的属性和方法</h3>
<div class="outline-text-3" id="text-orgecdebb0">
<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #66D9EF;">&#20462;&#39280;&#31526;</span> <span style="color: #F92672;">class</span> &#31867;&#21517; <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#31867;&#30340;&#23646;&#24615;</span>
<span class="linenr"> 3: </span>    <span style="color: #66D9EF;">&#20462;&#39280;&#31526;</span> <span style="color: #66D9EF;">&#31867;&#22411;</span> <span style="color: #FD971F;">&#23646;&#24615;1</span>;
<span class="linenr"> 4: </span>    <span style="color: #66D9EF;">&#20462;&#39280;&#31526;</span> <span style="color: #66D9EF;">&#31867;&#22411;</span> <span style="color: #FD971F;">&#23646;&#24615;2</span>;
<span class="linenr"> 5: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr"> 6: </span>    <span style="color: #66D9EF;">&#20462;&#39280;&#31526;</span> <span style="color: #66D9EF;">&#31867;&#22411;</span> <span style="color: #FD971F;">&#23646;&#24615;n</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#31867;&#30340;&#26041;&#27861;</span>
<span class="linenr"> 9: </span>    <span style="color: #66D9EF;">&#20462;&#39280;&#31526;</span> <span style="color: #66D9EF;">&#36820;&#22238;&#31867;&#22411;</span> <span style="color: #A6E22E;">&#26041;&#27861;&#21517;</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">&#21442;&#25968;&#21015;&#34920;</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">10: </span>        &#33509;&#24178;&#26041;&#27861;&#35821;&#21477;;
<span class="linenr">11: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>        <span style="color: #F92672;">return</span> &#26041;&#27861;&#36820;&#22238;&#20540;;
<span class="linenr">14: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">15: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
修饰符是什么？ <span class="underline">本质</span> 上是一种访问作用域限制，它可以用来修饰：类、属性和方法。关于修饰符有哪些，有什么用，稍后。
</p>

<p>
方法返回值，通过 <code>return</code> 语句实现，如果没有返回值，返回类型设置为 <code>void</code> ，可以省略 <code>return</code> 。
</p>

<p>
方法参数，可以包含 0 个或任意个参数，方法参数用于接收传递给方法的变量值，调用方法时，必须严格按照参数的定义一一传递。其中，可变参数用 <code>类型...</code> 定义，相当于数组类型。
</p>

<p>
为什么要使用可变参数，而不直接使用一个数组作为参数呢？主要因为数组参数：
</p>
<ul class="org-ul">
<li>调用方需要自己先构造 <code>String[]</code> ，比较麻烦；</li>
<li>调用方可以传入 <code>null</code> ，而对于可变参数，传入 0 个参数时，接收到的实际值是一个空数组而不是 <code>null</code> 。</li>
</ul>

<p>
关于 <b><b>参数绑定</b></b> 那些事儿，什么是参数绑定呢？调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。需要注意：
</p>
<ul class="org-ul">
<li>基本类型参数的传递，是调用方值的复制，双方各自的后续修改，互不影响；</li>
<li>引用类型参数的传递，是调用方址的复制，调用方和接收的参数变量，指向的是同一个对象，双方任一方对这个对象的修改，都会影响对方。</li>
</ul>
</div>
</div>

<div id="outline-container-org2f65293" class="outline-3">
<h3 id="org2f65293">类的构造方法</h3>
<div class="outline-text-3" id="text-org2f65293">
<p>
什么是 <b><b>构造方法</b></b> ？为什么需要构造方法？有什么需要注意的地方？
</p>

<p>
将一个 <code>class</code> 实例化为 <code>instance</code> 对象，实际上就是 <span class="underline">通过构造方法来初始化实例</span> 的。定义一个构造方法，能在创建 <code>instance</code> 对象的时候，就完成对象状态的初始化。构造方法也是方法，但又和普通方法有所不同，如下：
</p>
<ul class="org-ul">
<li>构造方法的名称就是类名；</li>
<li>构造方法没有返回值（也没有 <code>void</code> ）；</li>
<li>调用构造方法，必须用 <code>new</code> 操作符。</li>
</ul>

<p>
是不是任何 <code>class</code> 都有构造方法？是！
</p>
<ul class="org-ul">
<li>若一个类没有定义构造方法，编译器会自动生成一个默认构造方法，它没有参数，也没有执行语句；</li>
<li>若一个类已经定义构造方法，编译器就不再自动创建默认构造方法；</li>
<li>若既要能使用带参数的构造方法，又想保留不带参数的构造方法，只能把两个构造方法都定义出来。</li>
</ul>

<blockquote>
<p>
没有在构造方法中初始化的字段，默认值：
</p>
<ul class="org-ul">
<li>引用类型的字段默认是 <code>null</code> ；</li>
<li>数值类型的字段用默认值， <code>int</code> 类型默认值是 <code>0</code> ；</li>
<li>布尔类型默认值是 <code>false</code> 。</li>
</ul>
</blockquote>

<p>
若类中定义了多个构造方法，通过 <code>new</code> 操作符调用的时候，编译器会通过构造方法的参数数量、位置和类型自动区分。
</p>
</div>
</div>

<div id="outline-container-org0f42c84" class="outline-3">
<h3 id="org0f42c84">方法重载</h3>
<div class="outline-text-3" id="text-org0f42c84">
<p>
什么是方法重载？一系列实现相似功能， <b><b>同类同名不同参略返回</b></b> ，返回值类型通常相同的方法，称为方法重载 <code>Overload</code> 。它的目的在于，功能类似的方法使用同一名字，方便记忆，调用起来更简单。
</p>

<blockquote>
<p>
方法重载和方法覆写不同，方法覆写是在继承的体系中，子类实现父类的 <b><b>异类同名同参同返回</b></b> 的方法。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org2d9b977" class="outline-3">
<h3 id="org2d9b977">继承</h3>
<div class="outline-text-3" id="text-org2d9b977">
<p>
<b><b>继承</b></b> 是面向对象中非常强大的一种机制，可以复用代码。关于继承，需要注意：
</p>
<ul class="org-ul">
<li>Java 使用 <code>extends</code> 关键字来实现继承；</li>
<li>任何类，除了 <code>Object</code> ，都会继承自某个类，对于没有明确些 <code>extends</code> 的类，编译器会自动加上 <code>extends Object</code> ；</li>
<li>Java 中类的继承是单继承，一个类有且仅有一个父类，只有 <code>Object</code> 特殊，它没有父类；</li>
<li>子类无法访问父类的 <code>private</code> 修饰的属性字段和方法，可以用 <code>protected</code> 修饰，它可以把属性字段和方法的访问权限控制在继承树内部；</li>
<li>子类引用父类的属性字段是，可以用 <code>super.fieldName</code> 。</li>
</ul>

<blockquote>
<p>
在 Java 中，任何 <code>class</code> 的构造方法， <span class="underline">第一行语句</span> 必须是调用父类的构造方法。
</p>
<ul class="org-ul">
<li>如果没有明确地调用父类的构造方法，编译器会自动加上一句 <code>super()</code> ；</li>
<li>如果父类没有默认的构造方法，子类就必须显示调用 <code>super(方法参数列表)</code> 以便让编译器定位到父类的一个合适的构造方法；</li>
</ul>
</blockquote>

<p>
说明：子类不会继承任何父类的构造方法，子类默认的构造方法是编译器自动生成的，不是继承的。
</p>
</div>
</div>

<div id="outline-container-org30d90d6" class="outline-3">
<h3 id="org30d90d6">多态</h3>
<div class="outline-text-3" id="text-org30d90d6">
<blockquote>
<p>
多态：父类方法 → 子类覆写；父类变量 → 子类实例。
</p>
</blockquote>

<p>
多态的核心就是方法覆写（Override），代码中加上 <code>@Override</code> 可以让编译器帮助检查是否进行了正确的覆写，是非必需的。
</p>

<p>
<b><b>多态</b></b> 是什么？Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。
</p>

<p>
继承可以子类覆写父类的方法，如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 <code>final</code> 。
</p>

<p>
关于 <code>final</code> 修饰符：
</p>
<ul class="org-ul">
<li>用 <code>final</code> 修饰的类不能被继承；</li>
<li>用 <code>final</code> 修饰的属性字段必须在创建对象的时初始化，随后不可修改；</li>
<li>用 <code>final</code> 修饰的方法不能被覆写。</li>
</ul>
</div>
</div>

<div id="outline-container-org1cb678e" class="outline-3">
<h3 id="org1cb678e">抽象类和接口</h3>
<div class="outline-text-3" id="text-org1cb678e">
<blockquote>
<ul class="org-ul">
<li>抽象：抽象方法，仅有签名；不含语句，无法执行 → 类无实例，类必抽象，用于继承。</li>
<li>接口：单纯抽象，仅有签名，不含语句，不含字段。</li>
<li>实践：抽类公共逻辑，子类具体逻辑，接口层次抽象。</li>
</ul>
</blockquote>

<p>
在继承关系中，如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，可以把父类的方法声明为抽象方法。把一个方法声明为 <code>abstract</code> ，表示它是一个抽象方法，本身没有实现任何方法语句。抽象方法本身是无法执行的，故包含这个抽象方法的类无法被实例化（因为编译器无法编译这个类）。所以， <span class="underline">包含抽象方法的类必须申明为抽象类</span> 。
</p>

<p>
无法实例化的抽象类有什么用？因为抽象类本身 <span class="underline">被设计成只能用于被继承</span> ，因此，抽象类可以 <span class="underline">强迫子类实现其定义的抽象方法</span> ，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。
</p>

<blockquote>
<p>
尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。
</p>
</blockquote>

<p>
面向对象编程的 <span class="underline">本质</span> 就是：
</p>
<ul class="org-ul">
<li>上次代码之定义规范（如： <code>abstract class Person</code> ）;</li>
<li>不许要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>
</ul>

<blockquote>
<p>
在抽象类中，抽象方法 <span class="underline">本质上是定义接口规范</span> ：即规定高层类的接口，从而保证所有子类都有相同的接口实现，如此，多态就能发挥出威力。如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口 <code>interface</code> 。
</p>
</blockquote>

<p>
什么是 <b><b>接口</b></b> ？就是比抽象类还要抽象的纯抽象接口，如：
</p>
<ul class="org-ul">
<li>接口中连字段都不能有；</li>
<li>接口定义的所有方法默认都是 <code>public abstruct</code> ；</li>
<li>使用 <code>implements</code> 关键字来实现，且一个类可以实现多个 <code>interface</code> ;</li>
<li>一个接口可以继承另一个接口，也使用 <code>extends</code> 关键字，相当于扩展了接口的方法。</li>
</ul>

<blockquote>
<p>
合理设计 <code>interface</code> 和 <code>abstract class</code> 的继承关系，可以充分复用代码。一般来说：
</p>
<ul class="org-ul">
<li>公共逻辑适合放在 <code>abstract class</code> 中；</li>
<li>具体逻辑放到各个子类；</li>
<li>接口层次代表抽象程度。</li>
</ul>
</blockquote>

<p>
可以参考 Java 的集合类定义的一组接口、抽象类以及具体子类的继承关系：
</p>

<div class="figure">
<p><img src="../images/java/interface-abstract.jpg" alt="interface-abstract.jpg">
</p>
</div>

<p>
在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为它比抽象类更抽象。
</p>

<p>
在接口中，可以定义 <code>default</code> 方法，实现这个接口的类不必覆写 <code>default</code> 方法，它的目的是当需要给接口新增一个方法时，会涉及到修改全部子类，如果新增的是 <code>default</code> 方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。
</p>

<blockquote>
<p>
<code>default</code> 方法和抽象类的普通方法是有所不同的，因为 <code>interface</code> 没有字段， <code>default</code> 方法无法访问字段，而抽象类的普通方法可以访问实例字段。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org35cb7d5" class="outline-3">
<h3 id="org35cb7d5">静态字段和静态方法</h3>
<div class="outline-text-3" id="text-org35cb7d5">
<p>
所谓“静态”，其实就是一个 <code>class</code> 的所有 <code>instance</code> 对象 <b><b>共享的</b></b> ，可以根据 <code>类名.静态XX</code> 来访问的。通过实例变量调用的 <code>实例名.静态XX</code> ，只是 <span class="underline">编译器自动把实例名改成了类名</span> 而已。
</p>

<p>
静态字段和静态方法都是属于 <code>class</code> 而不属于实例，因此，静态方法内部，无法访问 <code>this</code> 变量，也无法访问实例字段，只能访问静态字段。
</p>

<blockquote>
<p>
静态方法经常用于工具类，如 <code>Arrays.sort()</code> 、 <code>Math.random()</code> 。也经常用于辅助方法，如 Java 程序的入口 <code>main()</code> 也是静态方法。
</p>
</blockquote>

<p>
接口 <code>interface</code> 是一个纯抽象类，它没有实例字段，但可以有静态字段，且静态字段必须为 <code>final</code> 类型，实际上， <code>interface</code> 的字段只能是 <code>public static final</code> 类型，所以可省略不写，编译器会自动加上。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">interface</span> <span style="color: #66D9EF;">Person</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">final</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">NAME</span> = 1;
<span class="linenr">3: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">final</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">FENAME</span> = 2;
<span class="linenr">4: </span>
<span class="linenr">5: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21487;&#30465;&#30053; public static final</span>
<span class="linenr">6: </span>    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">AGE</span> = 18;
<span class="linenr">7: </span>    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">FEAGE</span> = 19;
<span class="linenr">8: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5122a18" class="outline-3">
<h3 id="org5122a18">包</h3>
<div class="outline-text-3" id="text-org5122a18">
<p>
Java 定义了一种命名空间来解决命名冲突，称之为 <b><b>包</b></b> <code>package</code> ：
</p>
<ul class="org-ul">
<li>一个类总是属于某个包；</li>
<li>类名（如 <code>Person</code> ）只是一个简写，真正完整的类型是 <code>包名.类名</code> 。</li>
</ul>

<p>
包可以是多层结构，用 <code>.</code> 隔开，如 <code>java.util</code> 。注意，包没有父子关系。 <code>java.util</code> 和 <code>java.util.zip</code> 是不同的包，两者没有任何继承关系。没有定义包名的 <code>class</code> ，使用的是默认包，易引起命名冲突，不推荐。
</p>

<p>
项目中，需要按照包结构把 Java 文件组织起来，假设以 <code>package_sample</code> 作为根目录， <code>src</code> 作为源码目录，那么所有文件结构就是：
</p>

<div class="figure">
<p><img src="../images/java/package-src.jpg" alt="package-src.jpg">
</p>
</div>

<blockquote>
<p>
所有 Java 文件对应的目录层次要和包的层次一致。
</p>
</blockquote>

<p>
编译后的 <code>.class</code> 文件也需要按照包结构存放，如 IDE 把编译后的 <code>.class</code> 文件放到 <code>bin</code> 目录下，编译的文件结构如下：
</p>

<div class="figure">
<p><img src="../images/java/package-bin.jpg" alt="package-bin.jpg">
</p>
</div>

<p>
<b><b>包作用域</b></b> 是什么？不用 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 修饰的字段和方法就是包作用域。
</p>

<p>
在一个 <code>class</code> 中，总会引用其他的 <code>class</code> ，两种方式：
</p>
<ul class="org-ul">
<li>直接写出完整类名（显然这种方式比较痛苦）；</li>
<li>用 <code>import</code> 语句导入完整类名，也可以使用 <code>*</code> ，表示把这个包下面的所有 <code>class</code> 都导入进来（但不包括子包的 <code>class</code> ），不推荐，因为导入多个包后，不易区分使用的 <code>class</code> 属于哪个包；</li>
<li>还有一种 <code>import static</code> 的语法，可以导入一个类的静态字段和静态方法，很少使用。</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">Person.java</span>
<span class="linenr"> 2: </span><span style="color: #F92672;">package</span> <span style="color: #AE81FF;">pkg</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#23548;&#20837;&#23436;&#25972;&#31867;&#21517;</span>
<span class="linenr"> 5: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">mr</span>.<span style="color: #AE81FF;">man</span>.<span style="color: #66D9EF;">Arrays</span>;
<span class="linenr"> 6: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#23548;&#20837; miss.girl&#21253;&#30340;&#25152;&#26377; class</span>
<span class="linenr"> 7: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">miss</span>.<span style="color: #AE81FF;">girl</span>.*;
<span class="linenr"> 8: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#23548;&#20837; System &#31867;&#30340;&#25152;&#26377;&#38745;&#24577;&#23383;&#27573;&#21644;&#38745;&#24577;&#26041;&#27861;</span>
<span class="linenr"> 9: </span><span style="color: #F92672;">import</span> <span style="color: #F92672;">static</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">lang</span>.<span style="color: #AE81FF;">System</span>.*;
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Person</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">12: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">run</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">13: </span>        <span style="color: #66D9EF;">Arrays</span> <span style="color: #FD971F;">arraysMan</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Arrarys</span><span style="color: #A6E22E;">()</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#30452;&#25509;&#20351;&#29992;&#23436;&#25972;&#30340;&#31867;&#21517;</span>
<span class="linenr">16: </span>        <span style="color: #AE81FF;">mrs</span>.<span style="color: #AE81FF;">woman</span>.<span style="color: #66D9EF;">Arrarys</span> <span style="color: #FD971F;">arraysWoman</span> = <span style="color: #F92672;">new</span> <span style="color: #AE81FF;">mrs</span>.<span style="color: #AE81FF;">woman</span>.<span style="color: #66D9EF;">Arrays</span><span style="color: #A6E22E;">()</span>;
<span class="linenr">17: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">18: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">19: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
</pre>
</div>

<blockquote>
<p>
注意，如果导入的两个 <code>class</code> 名称相同，如 <code>mr.man.Arrays</code> 和 <code>mrs.womam.Arrays</code> ，那么只能 <code>import</code> 其中一个，另一个必须写完整类名。
</p>
</blockquote>

<p>
Java 编译器最终编译出的 <code>.class</code> 文件只使用完整类名，因此，在代码中，当编译器遇到一个 <code>class</code> 名称时：
</p>
<ul class="org-ul">
<li>如果是完整类名，就直接根据完整类名查找这个 <code>class</code> ；</li>
<li>如果是简单类名，按下面的顺序依次查找：
<ul class="org-ul">
<li>查找当前 <code>package</code> 是否存在这个 <code>class</code> ；</li>
<li>查找 <code>import</code> 的包是否包含这个 <code>class</code> ；</li>
<li>查找 <code>java.lang</code> 包是否包含这个 <code>class</code> ；</li>
</ul></li>
<li>如果按照上面的规则还无法确定类名，则编译报错。</li>
</ul>

<blockquote>
<p>
编写 class 的时候，编译器会自动帮我们做两个 import 动作：
</p>
<ul class="org-ul">
<li>默认自动 <code>import</code> 当前 <code>package</code> 的其他 <code>class</code> ；</li>
<li>默认自动 <code>import java.lang.*</code> 。</li>
</ul>
</blockquote>

<p>
来看一些最佳实践，如下：
</p>
<ul class="org-ul">
<li>为了避免名字冲突，需要确定唯一的包名，推荐的做法是使用倒置的域名来确保唯一性，如：
<ul class="org-ul">
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.jack.sample</li>
</ul></li>
<li>子包可以根据功能自行命名；</li>
<li>注意不要和 <code>java.lang</code> 包（被编译器自动导入的包）的类重名，如：
<ul class="org-ul">
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>&#x2026;</li>
</ul></li>
<li>注意也不要和 JDK 常用的类重名：
<ul class="org-ul">
<li>java.util.List</li>
<li>java.text.Format</li>
<li>&#x2026;</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org785af7d" class="outline-3">
<h3 id="org785af7d">作用域</h3>
<div class="outline-text-3" id="text-org785af7d">
<p>
在 Java 中，经常看到 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 这些修饰符，用来限定访问作用域。
</p>
<ul class="org-ul">
<li>public
<ul class="org-ul">
<li>定义为 <code>public</code> 的 <code>class</code> 、 <code>interface</code> 可以被其他任何类访问；</li>
<li>定义为 <code>public</code> 的 <code>field</code> 、 <code>method</code> 可以被其他类访问，前提是首先有访问 <code>class</code> 的权限；</li>
</ul></li>
<li>private
<ul class="org-ul">
<li>定位为 <code>private</code> 的 <code>field</code> 、 <code>method</code> 无法被其他类访问，推荐把 <code>private</code> 方法放到后面；</li>
<li>如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问 <code>private</code> 的权限；</li>
</ul></li>
<li>protected
<ul class="org-ul">
<li>作用于继承关系；</li>
<li>定义为 <code>protected</code> 的字段和方法可以被子类及其后代子类访问；</li>
</ul></li>
<li>package
<ul class="org-ul">
<li>只要在同一个包，就可以访问 <code>package</code> 权限的 <code>class</code> 、 <code>field</code> 和 <code>method</code> ；</li>
</ul></li>
<li>局部变量
<ul class="org-ul">
<li>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明出开始到对应的块结束；</li>
<li>注意，方法参数也是局部变量；</li>
</ul></li>
<li>final
<ul class="org-ul">
<li><code>final</code> 与访问权限不冲突，它有很多作用；</li>
<li>用 <code>final</code> 修饰 <code>class</code> 可以阻止被继承；</li>
<li>用 <code>final</code> 修饰 <code>method</code> 可以被子类覆写；</li>
<li>用 <code>final</code> 修饰 <code>field</code> 可以阻止被重新赋值；</li>
<li>用 <code>final</code> 修饰局部变量可以阻止被重新赋值。</li>
</ul></li>
</ul>

<p>
来看一些最佳实践：
</p>
<ul class="org-ul">
<li>如果不确实是否需要 <code>public</code> ，就不声明为 <code>public</code> ，即尽可能少地暴露对外的字段和方法；</li>
<li>把方法定义为 <code>package</code> 权限有助于测试，因为测试类和被测试类只要位于同一个 <code>package</code> ，测试代码就可以访问被测试类的 <code>package</code> 权限方法；</li>
<li>一个 <code>.java</code> 文件只能包含一个 <code>public</code> 类，但可以包含多个非 <code>public</code> 类，如果有 <code>public</code> 类，文件名必须和 <code>public</code> 类的名字相同。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-01-25 Sat 17:10</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2020-05-02 Sat 09:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
