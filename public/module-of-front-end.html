<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-05-02 Sat 09:09 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Module Of Front End</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" href="/css/animate.min.css" />
<link rel="stylesheet" href="/css/all.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script src="/js/jquery.min.js"></script>
<script src="/js/darkreader.js"></script>
<script src="/js/main.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">Module Of Front End</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7fc8812">模块化的基础</a></li>
<li><a href="#org38ac541">服务器端模块化</a>
<ul>
<li><a href="#org0be8cc3">CommonJS</a></li>
<li><a href="#orgdcb903c">NodeJS 如何实现不同模块可以使用相同的变量名</a></li>
<li><a href="#org5f396fd">模块的输出 module.exports 如何实现</a></li>
<li><a href="#org88ac7ca">exports 和 module.exports 的异同</a></li>
</ul>
</li>
<li><a href="#org8f7db35">浏览器端模块化</a>
<ul>
<li><a href="#org9bfc0cf">AMD·RequireJS</a></li>
<li><a href="#orga4d1e05">CMD·SeaJS</a></li>
</ul>
</li>
<li><a href="#orgcc97fe9">ES6 模块化</a></li>
<li><a href="#orgf668700">总结</a></li>
</ul>
</div>
</div>
<p>
→ <a href="https://www.cnblogs.com/dolphinX/p/4381855.html">前端模块化</a>
</p>

<p>
1995 年 5 月， Brendan Eich 只用了 10 天，就设计完成了 JavaScript 的第一版，so 对于 JavaScript 的规范化，不要要求太多，比如，它早期根本没有考虑模块化……
</p>

<p>
随着 web2.0 的发展， Ajax 技术得到广泛应用，各种前端库层出不穷， <span class="underline">前端代码日益膨胀</span> ， JavaScript 极其简单的代码组织规范已经 hold 不住如此庞大规模的代码了。
</p>

<p>
下面一起来看一下， JavaScript 模块化规范的血泪历程！
</p>

<div id="outline-container-org7fc8812" class="outline-2">
<h2 id="org7fc8812">模块化的基础</h2>
<div class="outline-text-2" id="text-org7fc8812">
<p>
<span class="underline">1. 函数封装</span>
</p>

<p>
最开始的模块就是在一个文件里面编写几个相关的函数，如此用时加载函数所在文件，直接调用即可。
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">fn1</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr">3: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">fn2</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">6: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr">7: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
<span class="underline">缺点</span> ：污染了全局变量，容易引起命名冲突，而且模块成员之间没什么关系。
</p>

<p>
<span class="underline">2. 对象封装</span>
</p>

<p>
为了解决上述问题，可以把所有的模块成员封装在一个对象中。如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">moduleInObj</span> = <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    var1: <span style="color: #E6DB74;">'Tom'</span>,
<span class="linenr"> 3: </span>    var2: <span style="color: #E6DB74;">'Jerry'</span>,
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #A6E22E;">fn1</span>: <span style="color: #F92672;">function</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr"> 7: </span>    <span style="color: #66D9EF;">}</span>,
<span class="linenr"> 8: </span>    <span style="color: #A6E22E;">fn2</span>: <span style="color: #F92672;">function</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 9: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr">10: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">11: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
如此，在需要模块时，引用包含模块的文件，通过 <code>对象名.模块名</code> 调用即可。
</p>

<p>
<span class="underline">缺点</span> ：外部可以随意修改内部成员，如 <code>moduleInObj.var2 = 'Bach'</code> 或 <code>moduleInObj.fn2 = function() { //....}</code> ，不安全啊。
</p>

<p>
<span class="underline">3. 立即执行函数封装</span>
</p>

<p>
为了隐藏细节，可以使用立即执行函数，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">moduleInIIEF</span> = <span style="color: #AE81FF;">(</span><span style="color: #F92672;">function</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">var1</span> = <span style="color: #E6DB74;">'Tom'</span>;
<span class="linenr"> 3: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">var2</span> = <span style="color: #E6DB74;">'Jerry'</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #F92672;">function</span> <span style="color: #A6E22E;">fn1</span><span style="color: #A6E22E;">()</span> <span style="color: #A6E22E;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr"> 7: </span>    <span style="color: #A6E22E;">}</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #F92672;">function</span> <span style="color: #A6E22E;">fn2</span><span style="color: #A6E22E;">()</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">10: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr">11: </span>    <span style="color: #A6E22E;">}</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21482;&#26292;&#38706;&#24819;&#35201;&#26292;&#38706;&#30340;&#21464;&#37327;&#25110;&#20989;&#25968;</span>
<span class="linenr">14: </span>    <span style="color: #F92672;">return</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">15: </span>        var1: var1,
<span class="linenr">16: </span>        fn2: fn2
<span class="linenr">17: </span>    <span style="color: #A6E22E;">}</span>
<span class="linenr">18: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
如此，在模块外部无法修改没有暴露出来的变量、函数。
</p>

<p>
<span class="underline">总结</span>
</p>

<p>
上述做法就是模块化的基础了，现在，让我们来看一下当前通行的 JavaScript 模块规范。
</p>
</div>
</div>

<div id="outline-container-org38ac541" class="outline-2">
<h2 id="org38ac541">服务器端模块化</h2>
<div class="outline-text-2" id="text-org38ac541">
</div>
<div id="outline-container-org0be8cc3" class="outline-3">
<h3 id="org0be8cc3">CommonJS</h3>
<div class="outline-text-3" id="text-org0be8cc3">
<p>
CommonJS 是 NodeJS 在服务端的模块化规范：
</p>
<ul class="org-ul">
<li>一个单独的文件就是一个模块，每个模块都是一个独立的作用域；</li>
<li>模块只有一个出口 &#x2013; <code>module.exports</code> 对象，把模块需要暴露的内容放入该对象；</li>
<li>加载模块使用 <code>require</code> 方法，该方法读取一个文件并执行，返回文件内部的 <code>module.exports</code> 对象。</li>
</ul>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">moduleInCommonJS.js</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">var1</span> = <span style="color: #E6DB74;">'Tom'</span>;
<span class="linenr"> 4: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">var2</span> = <span style="color: #E6DB74;">'Jerry'</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">fn1</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 7: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr"> 8: </span><span style="color: #AE81FF;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">fn2</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">11: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">....</span>
<span class="linenr">12: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#36890;&#36807; module.exports &#23545;&#35937;&#26292;&#38706;&#27169;&#22359;&#20869;&#23481;</span>
<span class="linenr">15: </span>module.exports = <span style="color: #AE81FF;">{</span>
<span class="linenr">16: </span>    fn1: fn1,
<span class="linenr">17: </span>    fn2: fn2
<span class="linenr">18: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
如此，当需要使用模块功能时，如下操作：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#20351;&#29992; require &#21152;&#36733; moduleInCommonJS</span>
<span class="linenr">2: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">moudleInCommonJS</span> = require<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'./moduleInCommonJS.js'</span><span style="color: #AE81FF;">)</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#35843;&#29992;&#27169;&#22359;&#30340;&#20989;&#25968;</span>
<span class="linenr">5: </span>moduleInCommonJS.fn1<span style="color: #AE81FF;">()</span>;
</pre>
</div>

<p>
注意，不同的实现对 <code>require</code> 时的路径有不同要求，通常可以省略 <code>.js</code> 扩展名，可以使用相对路径，也可以使用绝对路径。对于系统内置模块，甚至可以不写路径，直接使用模块名。
</p>

<p>
CommonJS 中的 <code>require</code> 加载是 <span class="underline">同步的</span> ，模块系统需要 <span class="underline">同步读取</span> 模块文件的内容（服务端内的硬盘读写速度很快），并编译执行以得到模块接口。
</p>

<p>
然而，浏览器端就尴尬了 -_||
</p>
</div>
</div>

<div id="outline-container-orgdcb903c" class="outline-3">
<h3 id="orgdcb903c">NodeJS 如何实现不同模块可以使用相同的变量名<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></h3>
<div class="outline-text-3" id="text-orgdcb903c">
<p>
JavaScript 语言本身并没有一种机制来保证不同的模块可以使用相同的变量名，那么 Node.js 是如何实现这一点的呢？
</p>

<p>
<b>！！！闭包！！！</b>
</p>

<p>
JavaScript 是一种函数式编程语言，它支持闭包 &#x2013; 把一段 JS 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。
</p>

<p>
如我们编写的 <code>hello.js</code> 代码如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">s</span> = <span style="color: #E6DB74;">'Hello'</span>
<span class="linenr">2: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">name</span> = <span style="color: #E6DB74;">'world'</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span>console.log<span style="color: #AE81FF;">(</span>s + <span style="color: #E6DB74;">' '</span> + name + <span style="color: #E6DB74;">'!'</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
↓↓↓ Node.js 加载了 <code>hello.js</code> 后，会把代码包装一下再执行，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">function</span> <span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">2: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35835;&#21462;&#30340; hello.js &#20195;&#30721;</span>
<span class="linenr">3: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">s</span> = <span style="color: #E6DB74;">'Hello'</span>
<span class="linenr">4: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">name</span> = <span style="color: #E6DB74;">'world'</span>
<span class="linenr">5: </span>
<span class="linenr">6: </span>    console.log<span style="color: #A6E22E;">(</span>s + <span style="color: #E6DB74;">' '</span> + name + <span style="color: #E6DB74;">'!'</span><span style="color: #A6E22E;">)</span>
<span class="linenr">7: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">hello.js &#20195;&#30721;&#32467;&#26463;</span>
<span class="linenr">8: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)()</span>
</pre>
</div>

<p>
如此以来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。
</p>
</div>
</div>

<div id="outline-container-org5f396fd" class="outline-3">
<h3 id="org5f396fd">模块的输出 module.exports 如何实现</h3>
<div class="outline-text-3" id="text-org5f396fd">
<p>
Node 利用 JavaScript 的函数式编程的特性，轻而易举实现了模块的隔离。但是，模块的输出 <code>module.exports</code> 怎么实现呢？
</p>

<p>
首先，Node 可以先准备一个对象 <code>module</code> ：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#20934;&#22791; module &#23545;&#35937;</span>
<span class="linenr"> 2: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">module</span> = <span style="color: #AE81FF;">{</span>
<span class="linenr"> 3: </span>    id: <span style="color: #E6DB74;">'hello'</span>,
<span class="linenr"> 4: </span>    exports: <span style="color: #66D9EF;">{}</span>
<span class="linenr"> 5: </span><span style="color: #AE81FF;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">load</span> = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">module</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 8: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35835;&#21462;&#30340; hello.js &#20195;&#30721;</span>
<span class="linenr"> 9: </span>    <span style="color: #F92672;">function</span> <span style="color: #A6E22E;">greet</span><span style="color: #66D9EF;">(</span><span style="color: #FD971F;">name</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">10: </span>        console.log<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">'Hello, '</span> + name + <span style="color: #E6DB74;">'!'</span><span style="color: #A6E22E;">)</span>
<span class="linenr">11: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>    module.exports = greet
<span class="linenr">14: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">hello.js &#20195;&#30721;&#32467;&#26463;</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #F92672;">return</span> module.exports
<span class="linenr">17: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">exported</span> = load<span style="color: #AE81FF;">(</span>moudle<span style="color: #AE81FF;">)</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#20445;&#23384; module</span>
<span class="linenr">22: </span>save<span style="color: #AE81FF;">(</span>module, exported<span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
可见，变量 <code>module</code> 是 Node 在加载 js 文件之前准备的一个变量，并将其传入加载函数，我们可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数。
</p>

<pre class="example">
exported →→ load(module) →→ module.exports
↓↓↓
save(module.exported) →→ save(module, module.exports)
</pre>

<p>
Node 会把 <code>module</code> 变量保存到某个地方，i.e. Node 保存了所有导入的 <code>module</code> ，当我们用 <code>require()</code> 获取 module 时，Node 找到对应的 <code>module</code> ，并把这个 <code>module</code> 的 <code>exports</code> 变量返回，这样另一个模块就顺利拿到了模块的输出。
</p>
</div>
</div>

<div id="outline-container-org88ac7ca" class="outline-3">
<h3 id="org88ac7ca">exports 和 module.exports 的异同</h3>
<div class="outline-text-3" id="text-org88ac7ca">
<p>
默认情况下，Node 准备的 <code>export</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code> ，如此你就可以直接往里面加东西，如：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>exports.foo = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span> <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">'foo'</span> <span style="color: #AE81FF;">}</span>
<span class="linenr">2: </span>exports.bar = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span> <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">'bar'</span> <span style="color: #AE81FF;">}</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span>module.exports.foo = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span> <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">'foo'</span> <span style="color: #AE81FF;">}</span>
<span class="linenr">5: </span>module.exports.bar = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span> <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">'bar'</span> <span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值，如：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>module.exports = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span> <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">'foo'</span> <span style="color: #AE81FF;">}</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#10004;</span>
<span class="linenr">2: </span>exports = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span> <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">'foo};          // &#10008;</span>
</pre>
</div>

<p>
为什么呢？
</p>

<p>
其实，从 <a href="#org5f396fd">模块的输出 module.exports 如何实现 ↑</a> 章节的 <code>load</code> 加载函数中就可以知道，最终返回的只有 <code>module.exports</code> ！ <code>exports</code> 不过是指向 <code>module.exports</code> ，也就是说， <code>exports</code> 的内存地址中的值存储的是指向 <code>module.exports</code> 的指针， <code>module.exports</code> 中的值才是真正返回的对象。
</p>

<pre class="example">
exports → module.exports → {}

exports ✘ module.exports → otherObjectTwo
↓
otherObjectOne

// 加载函数返回的只是 module.exports
</pre>

<p>
<b>！！！推荐始终使用 <code>module.exports</code> 这种相对安全的输出方式。</b>
</p>
</div>
</div>
</div>

<div id="outline-container-org8f7db35" class="outline-2">
<h2 id="org8f7db35">浏览器端模块化</h2>
<div class="outline-text-2" id="text-org8f7db35">
<p>
浏览器端，加载 JavaScript 文件的方式，是在文档头部插入 <code>&lt;script&gt;</code> 标签，但是脚本标签天生 <span class="underline">异步</span> ，传统的 CommonJS 模块在浏览器环境中就变成了 <span class="underline">普通的 <code>.js</code> 文件</span> &#x2013; 即没有避免全局变量污染，也没有解决依赖性。
</p>

<p>
那么，浏览器端的模块化，到底如何去规范呢？？
</p>

<p>
解决思路之一：开发一个服务器端组件，对模块代码作静态分析，将 <span class="underline">模块与它的依赖列表</span> 一起返回给浏览器端。这需要服务器安装额外的组件，并因此要调整一系列底层架构。
</p>

<p>
解决思路之二：用一套标准模板来封装模块定义，但是如何定义，如何加载呢？
</p>
</div>

<div id="outline-container-org9bfc0cf" class="outline-3">
<h3 id="org9bfc0cf">AMD·RequireJS</h3>
<div class="outline-text-3" id="text-org9bfc0cf">
<p>
→ <a href="https://requirejs.org/">RequireJS</a>
</p>

<p>
AMD（Asynchronous Module Definition）异步模块定义，是一个浏览器端模块化开发的规范，是 RequireJS 在推广过程中对模块定义的规范化产出。
</p>

<blockquote>
<p>
注意， AMD 并不是 JavaScript 原生支持，使用 AMD 需要引入对应的库函数 &#x2013; RequireJS 。
</p>
</blockquote>

<p>
RequireJS 主要解决两个问题：模块的 <span class="underline">异步加载</span> 和 <span class="underline">依赖性</span> 。
</p>

<p>
<span class="underline">1. 定义模块</span>
</p>

<p>
RequireJS 定义了一个全局函数 <code>define</code> ，用来定义模块，语法如下：
</p>

<pre class="example">
define(id?, dependencies?, factory);
</pre>

<p>
其中：
</p>
<ul class="org-ul">
<li><code>id</code> ，可选参数，用来定义模块的标识，缺省为脚本文件名；</li>
<li><code>dependencies</code> ，是一个当前模块依赖的模块名称数组；</li>
<li><code>factory</code> ，工厂方法，模块初始化要执行的 <span class="underline">函数或对象</span> ，如果为函数，它应该只被执行一次；如果是对象，它应该为模块的输出值。</li>
</ul>

<p>
<span class="underline">2. 加载模块</span>
</p>

<p>
AMD 推崇 <span class="underline">依赖前置</span> ，在定义模块的时候就要声明其依赖的模块。
</p>

<p>
在页面上使用 <code>require</code> 函数加载模块，语法如下：
</p>

<pre class="example">
require(dependencies?, callback);
</pre>

<p>
其中， <code>require()</code> 函数接受两个参数：
</p>
<ul class="org-ul">
<li><code>dependencies</code> ，表示所以来的模块数组；</li>
<li><code>callback</code> ，是一个回调函数，当依赖的模块都加载成功后，被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</li>
</ul>

<p>
<span class="underline">3. 示例代码</span>
</p>

<p>
来看一个简单的 RequireJS 示例代码。
</p>

<p>
假设文件的目录架构，如下：
</p>

<pre class="example">
Proj
|
|-- js
|   |-- lib
|       |-- jquery.js
|       |-- require.js
|
|-- index.html
|-- main.js
</pre>

<p>
在 <code>index.html</code> 头部引入 <code>require.js</code> 文件，如下：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #A6E22E;">scrpit</span> <span style="color: #FD971F;">data-main</span>=<span style="color: #E6DB74;">"./main"</span> <span style="color: #FD971F;">src</span>=<span style="color: #E6DB74;">"js/lib/require.js"</span> defer async&gt;&lt;/<span style="color: #A6E22E;">scrpit</span>&gt;
</pre>
</div>

<p>
其中，当 <code>require.js</code> 加载的时候会检查 <code>data-main</code> 属性，以获取 <span class="underline">入口脚本</span> （这里是 <code>main.js</code> ）。
</p>

<p>
编写 <code>main.js</code> 即可，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span>require.config<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span>
<span class="linenr"> 2: </span>    baseUrl: <span style="color: #E6DB74;">'./js/'</span>,
<span class="linenr"> 3: </span>    paths: <span style="color: #A6E22E;">{</span>
<span class="linenr"> 4: </span>        <span style="color: #E6DB74;">'jquery'</span>: <span style="color: #E6DB74;">'lib/jquery'</span>
<span class="linenr"> 5: </span>    <span style="color: #A6E22E;">}</span>
<span class="linenr"> 6: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>require<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">'jquery'</span><span style="color: #66D9EF;">]</span>, <span style="color: #F92672;">function</span><span style="color: #66D9EF;">(</span><span style="color: #FD971F;">$</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 9: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">jquery &#8594; $</span>
<span class="linenr">10: </span>    $<span style="color: #A6E22E;">(</span>document<span style="color: #A6E22E;">)</span>.ready<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">()</span> =&gt; <span style="color: #E6DB74;">{</span>
<span class="linenr">11: </span>        console.log<span style="color: #FD971F;">(</span><span style="color: #E6DB74;">'Hello World.'</span><span style="color: #FD971F;">)</span>;
<span class="linenr">12: </span>    <span style="color: #E6DB74;">}</span><span style="color: #A6E22E;">)</span>
<span class="linenr">13: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4d1e05" class="outline-3">
<h3 id="orga4d1e05">CMD·SeaJS</h3>
<div class="outline-text-3" id="text-orga4d1e05">
<p>
→ <a href="https://seajs.github.io/seajs/docs/">SeaJS</a>
</p>

<p>
CMD（Common Module Definition）通用模块定义，是国内发展出来的浏览器端模块化开发规范，相似， CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
</p>

<p>
<span class="underline">1. 定义模块</span>
</p>

<p>
SeaJS 也是为了解决模块的依赖性，语法如下：
</p>

<pre class="example">
define(id?, deps?, factory)
</pre>

<p>
其中， <code>factory</code> 接受三个参数 &#x2013; <code>function(require, exports, module)</code> ，如下：
</p>
<ul class="org-ul">
<li>第一个参数 <code>require(id)</code> 是一个方法，接受模块标识作为唯一此参数，用来获取其他模块提供的接口；</li>
<li>第二个参数 <code>exports</code> 是一个对象，用来向外提供模块接口；</li>
<li>第三个参数 <code>module</code> 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</li>
</ul>

<p>
<span class="underline">2. 加载模块</span>
</p>

<p>
CMD 推崇 <span class="underline">就近依赖</span> ，只有在用到某个模块的时候再去 <code>require</code> 加载。
</p>

<p>
<span class="underline">3. 示例代码</span>
</p>

<p>
来看一个简单的 SeaJS 示例代码：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; hello.js</span>
<span class="linenr">2: </span>define<span style="color: #AE81FF;">(</span><span style="color: #F92672;">function</span><span style="color: #66D9EF;">(</span><span style="color: #FD971F;">require</span>, <span style="color: #FD971F;">exports</span>, <span style="color: #FD971F;">module</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">3: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">$</span> = require<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">'jquery'</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">4: </span>
<span class="linenr">5: </span>    exports.sayHello = <span style="color: #F92672;">function</span><span style="color: #A6E22E;">()</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">6: </span>        $<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">'#hello'</span><span style="color: #E6DB74;">)</span>.toogle<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">'slow'</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">7: </span>    <span style="color: #A6E22E;">}</span>;
<span class="linenr">8: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
通过 SeaJS 来加载使用上面的模块，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>seajs.config<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span>
<span class="linenr">2: </span>    alias: <span style="color: #A6E22E;">{</span>
<span class="linenr">3: </span>        <span style="color: #E6DB74;">'jquery'</span>: <span style="color: #E6DB74;">'http:/modules.seajs.org/jquery/1.7.2/jquery.js'</span>
<span class="linenr">4: </span>    <span style="color: #A6E22E;">}</span>
<span class="linenr">5: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>;
<span class="linenr">6: </span>
<span class="linenr">7: </span>seajs.use<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">'./hello'</span>, <span style="color: #E6DB74;">'jquery'</span><span style="color: #66D9EF;">]</span>, <span style="color: #F92672;">function</span><span style="color: #66D9EF;">(</span><span style="color: #FD971F;">hello</span>, <span style="color: #FD971F;">$</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">8: </span>    $<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">'#beautiful-sea'</span><span style="color: #A6E22E;">)</span>.click<span style="color: #A6E22E;">(</span>hello.sayHello<span style="color: #A6E22E;">)</span>;
<span class="linenr">9: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
<span class="underline">4. AMD vs CMD</span>
</p>

<p>
AMD 和 CMD 的模块加载都是异步的，最大的区别是对 <span class="underline">依赖模块的执行时机</span> 处理不同。
</p>

<p>
AMD 在加载模块完成后就会执行该模块，所有模块都加载执行完成后，进入 require 的回调函数执行主逻辑。如此，依赖模块的执行顺序和书写顺序便无法保证一致 &#x2013; <span class="underline">谁下载快谁先执行</span> ，但是主逻辑一定在所有依赖加载完成后才执行。
</p>

<p>
CMD 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。
</p>

<p>
一般来说， AMD 用户体验好，因为没延迟，依赖模块提前执行了； CMD 性能号，因为只有用户需要的时候才执行。
</p>
</div>
</div>
</div>

<div id="outline-container-orgcc97fe9" class="outline-2">
<h2 id="orgcc97fe9">ES6 模块化<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></h2>
<div class="outline-text-2" id="text-orgcc97fe9">
<p>
ES6 模块的设计思想是尽量的 <span class="underline">静态化</span> ，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 CommondJS 和 AMD 模块，都只能在运行时确定这些东西。比如， CommonJS 模块就是对象，输入时必须查找对象属性。
</p>

<p>
<span class="underline">1. ES6 模块的定义和加载</span>
</p>

<p>
ES6 的模块化语法： <code>export</code> 命令用于规定模块的对外接口， <code>import</code> 命令用于输入其他模块提供的功能。如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#23450;&#20041;&#27169;&#22359; math.js</span>
<span class="linenr">2: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">basicNum</span> = 0;
<span class="linenr">3: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">add</span> = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">a</span>, <span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">4: </span>    <span style="color: #F92672;">return</span> a + b;
<span class="linenr">5: </span><span style="color: #AE81FF;">}</span>;
<span class="linenr">6: </span>
<span class="linenr">7: </span><span style="color: #F92672;">export</span> <span style="color: #AE81FF;">{</span>basicNum, add<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<p>
如需用到该模块，使用 <code>import</code> 引用即可，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#24341;&#29992;&#27169;&#22359;</span>
<span class="linenr">2: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">{</span> basicNum, add <span style="color: #AE81FF;">}</span> from <span style="color: #E6DB74;">'./math'</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">test</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">ele</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">5: </span>    ele.textContent = add<span style="color: #66D9EF;">(</span>99 + basicNum<span style="color: #66D9EF;">)</span>;
<span class="linenr">6: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
注意，使用 <code>import</code> 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 <code>export default</code> 命令，为模块指定默认输出。
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">export-default.js</span>
<span class="linenr">2: </span><span style="color: #F92672;">export</span> <span style="color: #F92672;">default</span> <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">3: </span>    console.log<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">'Hello World'</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">4: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
如此，其他模块加载该模块的时候， <code>import</code> 命令可以为该匿名函数指定任意名字，如：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">import-default.js</span>
<span class="linenr">2: </span><span style="color: #F92672;">import</span> customName from <span style="color: #E6DB74;">'./export-default'</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span>customName<span style="color: #AE81FF;">()</span>;                   <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; 'Hello World'</span>
</pre>
</div>

<p>
<span class="underline">2. ES6 模块和 CommonJS 模块的差异</span>
</p>

<p>
它们有两个重大差异：
</p>
<ul class="org-ul">
<li>CommonJS 模块输出的是一个 <span class="underline">值的拷贝</span> ，ES6 模块输出的是 <span class="underline">值的引用</span> ；</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ul>

<p>
来看一个代码示例：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">lib.js</span>
<span class="linenr"> 2: </span><span style="color: #F92672;">export</span> <span style="color: #F92672;">let</span> <span style="color: #FD971F;">conuter</span> = 3;
<span class="linenr"> 3: </span><span style="color: #F92672;">export</span> <span style="color: #F92672;">function</span> incCounter<span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 4: </span>    counter++;
<span class="linenr"> 5: </span><span style="color: #AE81FF;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#22312; main.js &#20013;&#21152;&#36733; lib.js</span>
<span class="linenr"> 8: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">{</span> counter, incCounter <span style="color: #AE81FF;">}</span> from <span style="color: #E6DB74;">'./lib'</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>console.log<span style="color: #AE81FF;">(</span>counter<span style="color: #AE81FF;">)</span>;           <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; 3</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>incCounter<span style="color: #AE81FF;">()</span>;
<span class="linenr">13: </span>console.log<span style="color: #AE81FF;">(</span>counter<span style="color: #AE81FF;">)</span>;           <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; 4</span>
</pre>
</div>

<p>
可见，ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是 <span class="underline">动态引用</span> ，并不会缓存值，模块里面的变量绑定其所在的模块。
</p>

<p>
第二个差异是因为 CommonJS 加载的是一个对象（即 <code>module.exports</code> 属性），该对象只有在脚本运行完才会生成；而 ES6 模块不是对象，它的对外接口只是已经静态定义，在代码静态解析阶段就会生成。
</p>
</div>
</div>

<div id="outline-container-orgf668700" class="outline-2">
<h2 id="orgf668700">总结</h2>
<div class="outline-text-2" id="text-orgf668700">
<p>
小结一下：
</p>
<ul class="org-ul">
<li>CommonJS 规范主要用于服务端编程，加载模块是同步的，并不适合浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD 、CMD 解决方案；</li>
<li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；</li>
<li>CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。但是依赖 SPM 打包，模块的加载逻辑偏重；</li>
<li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023027697415616">https://www.liaoxuefeng.com/wiki/1022910821149312/1023027697415616</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/ljianshu/Blog/issues/48">https://github.com/ljianshu/Blog/issues/48</a>
</p></div></div>

</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Date: 2020-01-19 Sun 19:49</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2020-05-02 Sat 09:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
